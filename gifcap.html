<html><head data-created="2020-12-06T22:27:49.220Z" data-modified="2020-12-06T22:27:12.730Z"><meta charset="UTF8"><link rel="stylesheet" href="hlstyles/default.css"><link rel="stylesheet" href="motherfucker.css"></head><body data-title="gifcap library"><div class="article-index"><ul data-type="pages_index"><li><span>&apos;23/06/03 23:20   </span><a target="_top" href="index_kdrgbtags.html">kdrgbtags, a ctags-style tool for RGBDS</a></li><li><span>&apos;23/06/03 22:37   </span><a target="_top" href="index_gbasm.html">GB Assembly Test</a></li><li><span>&apos;23/05/14 20:37   </span><a target="_top" href="index_firedemo.html">256-byte x86 fire demo</a></li><li><span>&apos;23/04/29 22:19   </span><a target="_top" href="index_b17.html">Reverse engineering a DOS game B17 Flying Fortress</a></li><li><span>&apos;22/01/03 23:33   </span><a target="_top" href="index_c64floats.html">C++ Commodore 64 floating point library</a></li><li><span>&apos;21/07/24 21:25   </span><a target="_top" href="index_OPL.html">OPL3 MIDI player</a></li><li><span>&apos;20/12/06 22:27   </span><a target="_top" href="index_gifcap.html">gifcap library</a></li><li><span>&apos;20/08/01 21:53   </span><a target="_top" href="index_doomloader.html">Doom level loader</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem3.html">NES Emulation Saga Part III</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem2.html">NES Emulation Saga Part II</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem1.html">NES Emulation Saga Part I</a></li><li><span>&apos;19/10/31 02:37   </span><a target="_top" href="index_kym.html">&#x1F3AE; Kori Yogan Mushi</a></li><li><span>&apos;19/08/03 20:43   </span><a target="_top" href="index_bespoke.html">&#x1F3AE; Bespoke Terror</a></li><li><span>&apos;19/08/03 20:32   </span><a target="_top" href="index_1hgj8.html">&#x1F3AE; Conker&apos;s BFD for Nintendo 486</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_trog.html">&#x1F3AE; TROG</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_stacker.html">&#x1F3AE; TTY Stacker</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_snake.html">&#x1F3AE; Snake</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_sm64.html">&#x1F3AE; SM64 HTML5</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_ronaldo.html">&#x1F3AE; 3D Ronaldo Football</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_roguelike.html">&#x1F3AE; Batch Roguelike</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_prototype.html">&#x1F3AE; Prototype</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_nestest.html">&#x1F3AE; NEStest</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_megamanblue.html">&#x1F3AE; MegaMan in the blue mountains</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD36.html">&#x1F3AE; Rune Stacker</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD31.html">&#x1F3AE; Doktornix And The Fetch Quest</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD29warmup.html">&#x1F3AE; Ludum Dare 29 Warmup</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD29.html">&#x1F3AE; Ground control to Major Tomashevsky</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD23warmup.html">&#x1F3AE; Ludum Dare 23 Warmup</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD23.html">&#x1F3AE; Ludum Dare 23</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_keystone.html">&#x1F3AE; Keystone Kapers for NES</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_gbmine.html">&#x1F3AE; GBMINE</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_choplifter.html">&#x1F3AE; Choplifter</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_breakout.html">&#x1F3AE; 6502 breakout</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_alibaba.html">&#x1F3AE; Ali Baba and the 40 thieves</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj6.html">&#x1F3AE; 1HGJ6</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj5.html">&#x1F3AE; 1HGJ5</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj4.html">&#x1F3AE; 1HGJ4</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj3.html">&#x1F3AE; 1HGJ3</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hg7.html">&#x1F3AE; 1HGJ7</a></li></ul></div>
<h1>gifcap - A library for easy, fast, creation of GIF files</h1>
<img src="images/mandelbrot1.gif"><img src="images/mandelbrot2.gif"><img src="images/mandelbrot3.gif"><br>
This is a small C language animated GIF writer library.<br>
<br>
It is available at <a href="https://bitbucket.org/kdrnic/gifcap/src/master/" target="_top">this bitbucket repository</a>, which includes a demo.<br>
<br>
It is based on 
<a href="https://www.jonolick.com/home/gif-writer" target="_top">Jon Olick&apos;s excellent GIF writer code</a>
<a href="https://web.archive.org/web/20200919044551/https://www.jonolick.com/home/gif-writer" target="_top">(archive)</a>.<br>
I have improved upon it by including the following features:<br>
<ul>
    <li>Multithreading - encode and write GIFs to disk while the next frame is rendered</li>
    <li>Faster encoding due to optimised algorithms</li>
    <li>Smaller filesizes</li>
</ul>
The &quot;gif&quot; in gifcap is pronounced as
<i>
    <span style="border-bottom:1px dotted">
        <span title="/&#x261;/: &apos;g&apos; in &apos;guy&apos;">&#x261;</span>
        <span title="/&#x26A;/: &apos;i&apos; in &apos;kit&apos;">&#x26A;</span>
        <span title="&apos;f&apos; in &apos;find&apos;">f</span>
    </span>,
    <span style="font-size:90%">GHIF.</span>
</i><br>
As a caveat, I have also left the code in a very poor, hacky state, and couldn&apos;t be arsed to clean it.<br>
The account below I believe is an interesting exploration of some computer science problems.<br>
<h2>History</h2>
In december 2018 while working on collision code for my 3D FPS engine I decided to add GIF output as a debugging aid.<br>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I added both demo recording and gif output, and managed to fix it <a href="https://t.co/cfgu9Ud6Ai" target="_top">pic.twitter.com/cfgu9Ud6Ai</a></p>&#x2014; REGULAR KDRNIC now with FRUSTRATION (@kdrnic) <a href="https://twitter.com/kdrnic/status/1074481252055597056?ref_src=twsrc%5Etfw" target="_top">December 17, 2018</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>
The GIFs it would generate were of enormous file size, and it would leave the application running very slowly even for relatively small, low FPS gifs.<br>
<h2>Improving filesize</h2>
Improving filesize was simply a matter of adding support for what one can call delta encoding, or which some GIF software calls &quot;greenscreen&quot;, that is,
to only store the pixels changed from one frame to the next. The image below, from 
<a href="http://blog.bahraniapps.com/gifcam/" target="_top">GifCam&apos;s GIF editor</a>
<a href="https://web.archive.org/web/20201130103642/http://blog.bahraniapps.com/gifcam/" target="_top">(archive)</a>
 shows in green unchanged areas from one frame to the next, which need not be stored, saving disk space.<br><br>
<img src="images/gifgreenscreen.png"><br>
JO&apos;s lib lacked support for such frames, likely due to simplicity concerns (he boasts the 398 lines of code).
The code changes to achieve this were quite simple:<br>
<code class="c" data-hled="true">
<span class="hljs-comment">//if using all colours, on the first frame, or new palette, can&apos;t delta-frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_GREENSCREEN (gif-&gt;numColors == 256 || gif-&gt;frame == 0 || genPalette)</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *indexedPixels = gif-&gt;buf[<span class="hljs-number">0</span>], *oldPixels = gif-&gt;buf[<span class="hljs-number">1</span>];
<span class="hljs-keyword">if</span>(NO_GREENSCREEN &amp;&amp; oldPixels) <span class="hljs-built_in">memset</span>(oldPixels, <span class="hljs-number">0</span>, size);

<span class="hljs-comment">// Write new GIF frame to indexedPixels</span>
<span class="hljs-comment">// [...]</span>


<span class="hljs-comment">//calc delta-frame</span>
<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size * !NO_GREENSCREEN; i++){
    <span class="hljs-keyword">if</span>(indexedPixels[i] == oldPixels[i]) indexedPixels[i] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> oldPixels[i] = indexedPixels[i];
}

<span class="hljs-comment">// Graphic Control Extension</span>
<span class="hljs-comment">//last byte here tells whether to use a transparent colour and delta frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLOCK_START NO_GREENSCREEN ? <span class="hljs-meta-string">&quot;\x21\xf9\x04\x00&quot;</span> : <span class="hljs-meta-string">&quot;\x21\xf9\x04\x05&quot;</span></span>
fwrite(BLOCK_START, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, gif-&gt;fp);
</code><div style="display: none;">
//if using all colours, on the first frame, or new palette, can&apos;t delta-frame
#define NO_GREENSCREEN (gif-&gt;numColors == 256 || gif-&gt;frame == 0 || genPalette)

unsigned char *indexedPixels = gif-&gt;buf[0], *oldPixels = gif-&gt;buf[1];
if(NO_GREENSCREEN &amp;&amp; oldPixels) memset(oldPixels, 0, size);

// Write new GIF frame to indexedPixels
// [...]


//calc delta-frame
for(i = 0; i &lt; size * !NO_GREENSCREEN; i++){
	if(indexedPixels[i] == oldPixels[i]) indexedPixels[i] = 0;
	else oldPixels[i] = indexedPixels[i];
}

// Graphic Control Extension
//last byte here tells whether to use a transparent colour and delta frame
#define BLOCK_START NO_GREENSCREEN ? &quot;\x21\xf9\x04\x00&quot; : &quot;\x21\xf9\x04\x05&quot;
fwrite(BLOCK_START, 4, 1, gif-&gt;fp);
</div>
<br>
And the benefits in file size were drastic. Note it is not necessary to perform run length encoding or other such methods on the pixels
that are marked as unchanged: the LZW compression algorithm takes care of that.<br>
<h2>Optimising encoding</h2>
GIF encoding, specially at &quot;higher resolutions&quot; such as a mind-breaking 320x240, was going quite slow, single digit frame-per-second values.
Some very basic profiling showed that the big hotspot in GIF encoding was the &quot;quantization&quot; step, that is, the code to turn a 24-bit R8G8B8 colour value
into an 8-bit palette index. In JO&apos;s original library this hotspot is a straightforward linear search:<br>
<code class="c" data-hled="true">
<span class="hljs-comment">//naive search</span>
<span class="hljs-keyword">int</span> rgb[<span class="hljs-number">3</span>] = { ditheredPixels[k+<span class="hljs-number">0</span>], ditheredPixels[k+<span class="hljs-number">1</span>], ditheredPixels[k+<span class="hljs-number">2</span>] };
<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; gif-&gt;numColors &amp;&amp; bestd; ++i){
    <span class="hljs-keyword">int</span> bb = palette[i*<span class="hljs-number">3</span>+<span class="hljs-number">0</span>]-rgb[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">int</span> gg = palette[i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>]-rgb[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> rr = palette[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>]-rgb[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">int</span> d = bb*bb + gg*gg + rr*rr;
    <span class="hljs-keyword">if</span>(d &lt; bestd) {
        bestd = d;
        best = i;
    }
}
</code><div style="display: none;">
//naive search
int rgb[3] = { ditheredPixels[k+0], ditheredPixels[k+1], ditheredPixels[k+2] };
for(i = 0; i &lt; gif-&gt;numColors &amp;&amp; bestd; ++i){
	int bb = palette[i*3+0]-rgb[0];
	int gg = palette[i*3+1]-rgb[1];
	int rr = palette[i*3+2]-rgb[2];
	int d = bb*bb + gg*gg + rr*rr;
	if(d &lt; bestd) {
		bestd = d;
		best = i;
	}
}
</div>
<br>
The computer-science savvy friend will reframe this problem, every colour is a point in 3D space, the quantization step is a nearest-neighbour search,
and the palette needs to be turned into some sort of tree data structure. The answer is a kd-tree. To quote Wikipedia:<br>
<i style="padding-left: 32pt;">
In computer science, a <b>k-d tree</b> (short for k-dimensional tree) is a space-partitioning data structure for <b>organizing points in a
k-dimensional space</b>. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional
search key (e.g. range searches and <b>nearest neighbor searches</b>). k-d trees are a special case of binary space partitioning trees.
</i>
<br>
The code for a kd-tree implementation I based on 
<a href="https://rosettacode.org/wiki/K-d_tree" target="_top">Rosetta Code&apos;s example implementation</a>
<a href="https://web.archive.org/web/20200528191816/https://rosettacode.org/wiki/K-d_tree" target="_top">(archive)</a>,
shamelessly. The quantization is now done in two steps:<br>
<code class="c" data-hled="true">
<span class="hljs-comment">//Build kdtree from palette</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kd_node_t</span> *<span class="hljs-title">palkdn</span> = <span class="hljs-title">gif</span>-&gt;<span class="hljs-title">palkdn</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kd_node_t</span> *<span class="hljs-title">palkdt</span> = <span class="hljs-title">gif</span>-&gt;<span class="hljs-title">palkdt</span>, <span class="hljs-title">kdcol</span>;</span>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kd_node_t</span> *<span class="hljs-title">kdbest</span>;</span>
<span class="hljs-keyword">if</span>(gif-&gt;frame == <span class="hljs-number">0</span> || genPalette){
    <span class="hljs-keyword">for</span>(i = (gif-&gt;numColors != <span class="hljs-number">256</span>); i &lt; gif-&gt;numColors + (gif-&gt;numColors != <span class="hljs-number">256</span>); i++){
        palkdn[i].x[<span class="hljs-number">0</span>] = palette[i*<span class="hljs-number">3</span>+<span class="hljs-number">0</span>];
        palkdn[i].x[<span class="hljs-number">1</span>] = palette[i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>];
        palkdn[i].x[<span class="hljs-number">2</span>] = palette[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>];
        palkdn[i].idx = i;
    }
    palkdt = gif-&gt;palkdt = kdtree_make_tree(palkdn + (gif-&gt;numColors != <span class="hljs-number">256</span>), gif-&gt;numColors, <span class="hljs-number">0</span>);
}

<span class="hljs-comment">// [...]</span>

<span class="hljs-comment">//Find best fit colour with kd-tree</span>
kdcol.x[<span class="hljs-number">0</span>] = ditheredPixels[k+<span class="hljs-number">0</span>];
kdcol.x[<span class="hljs-number">1</span>] = ditheredPixels[k+<span class="hljs-number">1</span>];
kdcol.x[<span class="hljs-number">2</span>] = ditheredPixels[k+<span class="hljs-number">2</span>];
kdtree_nearest(palkdt, &amp;kdcol, <span class="hljs-number">0</span>, &amp;kdbest, &amp;bestd);
best = kdbest-&gt;idx;
</code><div style="display: none;">
//Build kdtree from palette
struct kd_node_t *palkdn = gif-&gt;palkdn;
struct kd_node_t *palkdt = gif-&gt;palkdt, kdcol;
const struct kd_node_t *kdbest;
if(gif-&gt;frame == 0 || genPalette){
	for(i = (gif-&gt;numColors != 256); i &lt; gif-&gt;numColors + (gif-&gt;numColors != 256); i++){
		palkdn[i].x[0] = palette[i*3+0];
		palkdn[i].x[1] = palette[i*3+1];
		palkdn[i].x[2] = palette[i*3+2];
		palkdn[i].idx = i;
	}
	palkdt = gif-&gt;palkdt = kdtree_make_tree(palkdn + (gif-&gt;numColors != 256), gif-&gt;numColors, 0);
}

// [...]

//Find best fit colour with kd-tree
kdcol.x[0] = ditheredPixels[k+0];
kdcol.x[1] = ditheredPixels[k+1];
kdcol.x[2] = ditheredPixels[k+2];
kdtree_nearest(palkdt, &amp;kdcol, 0, &amp;kdbest, &amp;bestd);
best = kdbest-&gt;idx;
</div>
<br>
The performance benefits were drastic.<br>
<h2>Multithreading</h2>
Still, each frame necessarily takes a decent amount of time to encode. And disk I/O, which can block, was another factor<br>
The library could already do over 12 FPS for decent resolutions, but I intended this for a realtime application, such as the game engine.
Those have to run at 60 FPS, but they also have to run smoothly - a frame can&apos;t take much longer than the other. And in the naive way to call the
encoder, blocking the renderer for GIF output at every 5th frame, the performance was thus degraded.<br>
<br>
I thus applied the PTHREADS library to straightforwardly allow encoding a frame while the main application continued to run:<br>
<code class="c" data-hled="true">
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">gif_func</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
    <span class="hljs-comment">// [...]</span>
    <span class="hljs-keyword">do</span>{
        pthread_mutex_lock(&amp;gc-&gt;thr_lock);
        <span class="hljs-comment">//Wait for a frame to encode</span>
        <span class="hljs-keyword">while</span>(!gc-&gt;thr_has_frame){
            pthread_cond_wait(&amp;gc-&gt;thr_cond, &amp;gc-&gt;thr_lock);
        }
        <span class="hljs-comment">// [...]</span>
        <span class="hljs-comment">// Encode frame</span>
        jo_gif_frame(&amp;gc-&gt;jo, c, (gc-&gt;delta + gc-&gt;delta_error) / <span class="hljs-number">100</span>, gc-&gt;gen_pal);
        <span class="hljs-comment">// [...]</span>
        gc-&gt;thr_has_frame = <span class="hljs-number">0</span>;
        pthread_mutex_unlock(&amp;gc-&gt;thr_lock);
    } <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gifcap_start</span><span class="hljs-params">(<span class="hljs-keyword">gifcap_t</span> *cap, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">gifcap_param_t</span> params)</span>
</span>{
    <span class="hljs-comment">// [...]</span>
    cap-&gt;thr_has_frame = <span class="hljs-number">0</span>;
    cap-&gt;thr_cond = PTHREAD_COND_INITIALIZER;
    cap-&gt;thr_lock = PTHREAD_MUTEX_INITIALIZER;
    cap-&gt;thr_arg.gc = cap;
    <span class="hljs-keyword">if</span>(pthread_create(&amp;cap-&gt;thr, <span class="hljs-number">0</span>, gif_func, &amp;cap-&gt;thr_arg)){
        <span class="hljs-comment">// [...]</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-comment">// [...]</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gifcap_frame</span><span class="hljs-params">(<span class="hljs-keyword">gifcap_t</span> *cap, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *buf)</span>
</span>{
    pthread_mutex_lock(&amp;cap-&gt;thr_lock);
    <span class="hljs-comment">//Copy frame data to another buffer</span>
    <span class="hljs-built_in">memcpy</span>(cap-&gt;thr_arg.frame_data, buf, cap-&gt;jo.width * cap-&gt;jo.height * <span class="hljs-number">4</span>);
    <span class="hljs-comment">//Signal that we have a frame to encode</span>
    cap-&gt;thr_has_frame = <span class="hljs-number">1</span>;
    pthread_cond_signal(&amp;cap-&gt;thr_cond);
    pthread_mutex_unlock(&amp;cap-&gt;thr_lock);
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gifcap_end</span><span class="hljs-params">(<span class="hljs-keyword">gifcap_t</span> *cap)</span>
</span>{
    pthread_mutex_lock(&amp;cap-&gt;thr_lock);
    pthread_cancel(cap-&gt;thr);
    <span class="hljs-comment">// [...]</span>
}
</code><div style="display: none;">
static void *gif_func(void *arg)
{
	// [...]
	do{
		pthread_mutex_lock(&amp;gc-&gt;thr_lock);
		//Wait for a frame to encode
		while(!gc-&gt;thr_has_frame){
			pthread_cond_wait(&amp;gc-&gt;thr_cond, &amp;gc-&gt;thr_lock);
		}
		// [...]
		// Encode frame
		jo_gif_frame(&amp;gc-&gt;jo, c, (gc-&gt;delta + gc-&gt;delta_error) / 100, gc-&gt;gen_pal);
		// [...]
		gc-&gt;thr_has_frame = 0;
		pthread_mutex_unlock(&amp;gc-&gt;thr_lock);
	} while(1);
	return 0;
}
int gifcap_start(gifcap_t *cap, const char *filename, gifcap_param_t params)
{
	// [...]
	cap-&gt;thr_has_frame = 0;
	cap-&gt;thr_cond = PTHREAD_COND_INITIALIZER;
	cap-&gt;thr_lock = PTHREAD_MUTEX_INITIALIZER;
	cap-&gt;thr_arg.gc = cap;
	if(pthread_create(&amp;cap-&gt;thr, 0, gif_func, &amp;cap-&gt;thr_arg)){
		// [...]
		return 1;
	}
	// [...]
	return 0;
}
void gifcap_frame(gifcap_t *cap, unsigned char *buf)
{
	pthread_mutex_lock(&amp;cap-&gt;thr_lock);
	//Copy frame data to another buffer
	memcpy(cap-&gt;thr_arg.frame_data, buf, cap-&gt;jo.width * cap-&gt;jo.height * 4);
	//Signal that we have a frame to encode
	cap-&gt;thr_has_frame = 1;
	pthread_cond_signal(&amp;cap-&gt;thr_cond);
	pthread_mutex_unlock(&amp;cap-&gt;thr_lock);
}
void gifcap_end(gifcap_t *cap)
{
	pthread_mutex_lock(&amp;cap-&gt;thr_lock);
	pthread_cancel(cap-&gt;thr);
	// [...]
}
</div>
<br>
Of course the main application will still block if the GIF encoder cannot keep up - but the speed of the main application is thus decoupled
from the speed of the GIF encoder.<br>
<h2>Mandelbrot demo</h2>
I was thinking of what to use as a GIF encoding demo. I originaly thought of using some implementation of 
<a href="https://fabiensanglard.net/doom_fire_psx/" target="_top">famous PSX Doom fire effect as explained by Fabien Sanglard</a>
<a href="https://web.archive.org/web/20201107223603/https://fabiensanglard.net/doom_fire_psx/" target="_top">(archive)</a>,
but as Jon Olick&apos;s original page on his library has an animation based on a Julia set I opted to do one based on the similar Mandelbrot set instead.<br>
<img src="images/mandelbrotfull.png"><br>
The code is again &quot;borrowed&quot; from  
<a href="https://rosettacode.org/wiki/Mandelbrot_set" target="_top">Rosetta Code</a>
<a href="https://web.archive.org/web/20200508184456/https://rosettacode.org/wiki/Mandelbrot_set" target="_top">(archive)</a>.<br>
<br>
It uses Allegro 4, as most of my graphical applications.<br>
The nice colouring algorithm is from <a href="https://math.stackexchange.com/a/1995109" target="_top">this StackExchange post</a>.<br>
<h2>Post scriptum</h2>
Many thanks for Jon Olick for the original library, without which this wouldn&apos;t exist.<br>
Thanks for Rosetta Code, as a convenient code repository.<br>
If you use this, specially if you improve upon it, please give me a shout at Twitter or the IRC.

</body></html>