<html><head data-created="2022-01-03T23:33:23.756Z" data-modified="2022-01-03T23:32:47.934Z"><meta charset="UTF8"><link rel="stylesheet" href="hlstyles/default.css"><link rel="stylesheet" href="motherfucker.css"></head><body data-title="C++ Commodore 64 floating point library"><div class="article-index"><ul data-type="pages_index"><li><span>&apos;23/04/29 22:19   </span><a target="_top" href="index_b17.html">Reverse engineering a DOS game B17 Flying Fortress</a></li><li><span>&apos;22/01/03 23:33   </span><a target="_top" href="index_c64floats.html">C++ Commodore 64 floating point library</a></li><li><span>&apos;21/07/24 21:25   </span><a target="_top" href="index_OPL.html">OPL3 MIDI player</a></li><li><span>&apos;20/12/06 22:27   </span><a target="_top" href="index_gifcap.html">gifcap library</a></li><li><span>&apos;20/08/01 21:53   </span><a target="_top" href="index_doomloader.html">Doom level loader</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem3.html">NES Emulation Saga Part III</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem2.html">NES Emulation Saga Part II</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem1.html">NES Emulation Saga Part I</a></li><li><span>&apos;19/10/31 02:37   </span><a target="_top" href="index_kym.html">&#x1F3AE; Kori Yogan Mushi</a></li><li><span>&apos;19/08/03 20:43   </span><a target="_top" href="index_bespoke.html">&#x1F3AE; Bespoke Terror</a></li><li><span>&apos;19/08/03 20:32   </span><a target="_top" href="index_1hgj8.html">&#x1F3AE; Conker&apos;s BFD for Nintendo 486</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_trog.html">&#x1F3AE; TROG</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_stacker.html">&#x1F3AE; TTY Stacker</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_snake.html">&#x1F3AE; Snake</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_sm64.html">&#x1F3AE; SM64 HTML5</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_ronaldo.html">&#x1F3AE; 3D Ronaldo Football</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_roguelike.html">&#x1F3AE; Batch Roguelike</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_prototype.html">&#x1F3AE; Prototype</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_nestest.html">&#x1F3AE; NEStest</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_megamanblue.html">&#x1F3AE; MegaMan in the blue mountains</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD36.html">&#x1F3AE; Rune Stacker</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD31.html">&#x1F3AE; Doktornix And The Fetch Quest</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD29warmup.html">&#x1F3AE; Ludum Dare 29 Warmup</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD29.html">&#x1F3AE; Ground control to Major Tomashevsky</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD23warmup.html">&#x1F3AE; Ludum Dare 23 Warmup</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD23.html">&#x1F3AE; Ludum Dare 23</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_keystone.html">&#x1F3AE; Keystone Kapers for NES</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_gbmine.html">&#x1F3AE; GBMINE</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_choplifter.html">&#x1F3AE; Choplifter</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_breakout.html">&#x1F3AE; 6502 breakout</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_alibaba.html">&#x1F3AE; Ali Baba and the 40 thieves</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj6.html">&#x1F3AE; 1HGJ6</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj5.html">&#x1F3AE; 1HGJ5</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj4.html">&#x1F3AE; 1HGJ4</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj3.html">&#x1F3AE; 1HGJ3</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hg7.html">&#x1F3AE; 1HGJ7</a></li></ul></div>
<h1>Floating point arithmetics from the Commodore 64 in C++</h1>
<img src="images/mandelbrot_c64_600x450.png"><br>
This is an experiment in 1. using C++ operator overloading to implement software floating point arithmetics and 2. measuring the accuracy and performance of the Commodore 64&apos;s floating point library.<br>
It takes the <a href="index_nesem1.html" target="_top">6502 core I developed for my NES emulator</a>, using it to emulate a Commodore 64 making calls to the kernel&apos;s floating point arithmetic routines.<br>
The interface, a C++ class, can be used more or less like a regular float.<br>
It is available at <a href="https://github.com/kdrnic/c64floats" target="_top">this github repository</a>, which includes a mandelbrot generator demo, which was used to generate the image above.
The mandelbrot code is very similar to that for <a href="index_gifcap.html" target="_top">the gifcap library</a>.<br>
<br>
<h2>The interface</h2>
The main interface is just a class with a bunch of operators overloaded:<br>
<code class="cpp" data-hled="true">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C64Float</span>
{</span>
    <span class="hljs-comment">//(slightly abridged)</span>
    <span class="hljs-keyword">public</span>:
    C64Float <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>;
    C64Float <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>;
    C64Float <span class="hljs-keyword">operator</span> -(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>;
    C64Float <span class="hljs-keyword">operator</span> /(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>;
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
    C64Float <span class="hljs-keyword">operator</span> -() <span class="hljs-keyword">const</span>;
    C64Float <span class="hljs-keyword">operator</span> *=(<span class="hljs-keyword">const</span> C64Float other){ *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> * other; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    C64Float <span class="hljs-keyword">operator</span> +=(<span class="hljs-keyword">const</span> C64Float other){ *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> + other; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    C64Float <span class="hljs-keyword">operator</span> /=(<span class="hljs-keyword">const</span> C64Float other){ *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / other; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    C64Float <span class="hljs-keyword">operator</span> -=(<span class="hljs-keyword">const</span> C64Float other){ *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> - other; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    C64Float <span class="hljs-keyword">operator</span> ++(){ *<span class="hljs-keyword">this</span> += unit; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    C64Float <span class="hljs-keyword">operator</span> --(){ *<span class="hljs-keyword">this</span> -= unit; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; }
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(C64Float other)  <span class="hljs-keyword">const</span>{ <span class="hljs-keyword">return</span> !((*<span class="hljs-keyword">this</span>) == other) &amp;&amp; !((*<span class="hljs-keyword">this</span>) &gt; other); }
    C64Float(<span class="hljs-keyword">int</span> i);
    C64Float(<span class="hljs-keyword">double</span> d);
};
</code><div style="display: none;">
class C64Float
{
    //(slightly abridged)
	public:
	C64Float operator *(const C64Float other) const;
	C64Float operator +(const C64Float other) const;
	C64Float operator -(const C64Float other) const;
	C64Float operator /(const C64Float other) const;
	bool operator &gt;(const C64Float other) const;
	bool operator ==(const C64Float other) const;
	operator int() const;
	C64Float operator -() const;
	C64Float operator *=(const C64Float other){ *this = *this * other; return *this; }
	C64Float operator +=(const C64Float other){ *this = *this + other; return *this; }
	C64Float operator /=(const C64Float other){ *this = *this / other; return *this; }
	C64Float operator -=(const C64Float other){ *this = *this - other; return *this; }
	C64Float operator ++(){ *this += unit; return *this; }
	C64Float operator --(){ *this -= unit; return *this; }
	bool operator &lt;(C64Float other)  const{ return !((*this) == other) &amp;&amp; !((*this) &gt; other); }
	C64Float(int i);
	C64Float(double d);
};
</div>
<br>
The lib also includes overloads for the common math.h/cmath functions (those which are available in the C64) and a <a href="https://en.cppreference.com/w/cpp/language/user_literal" target="_top">user-defined literal thingamabob</a> for convenience:<br>
<code class="cpp" data-hled="true">
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">round</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">abs</span><span class="hljs-params">(C64Float f)</span></span>; 
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">sqrt</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">atan</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">tan</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">exp</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">pow</span><span class="hljs-params">(C64Float f1, C64Float f2)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">log</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">sin</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">cos</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">log2</span><span class="hljs-params">(C64Float f)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> C64Float <span class="hljs-title">log10</span><span class="hljs-params">(C64Float f)</span></span>;
C64Float <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _C64F(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *);
</code><div style="display: none;">
static C64Float round(C64Float f);
static C64Float abs(C64Float f); 
static C64Float sqrt(C64Float f);
static C64Float atan(C64Float f);
static C64Float tan(C64Float f);
static C64Float exp(C64Float f);
static C64Float pow(C64Float f1, C64Float f2);
static C64Float log(C64Float f);
static C64Float sin(C64Float f);
static C64Float cos(C64Float f);
static C64Float log2(C64Float f);
static C64Float log10(C64Float f);
C64Float operator &quot;&quot; _C64F(const char *);
</div>
<h2>Internals</h2>
Internally it works by emulating a partial Commodore 64 as mentioned.
Modifying the code from the NES emulator to behave sufficiently like a Commodore 64 wasn&apos;t very difficult, since the core was sufficiently machine-agnostic.
Since actual IO is not necessary It is enough to map some addresses to ROM, and to simulate a copy of a routine to zero-page RAM which the Commodore 64 does on its boot code (which we don&apos;t use).
<code class="cpp" data-hled="true">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C64Memory</span> :</span> <span class="hljs-keyword">public</span> Memory
{
    <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">uint8_t</span> ram[<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>];
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> rom_kernal[<span class="hljs-number">8</span> * <span class="hljs-number">1024</span>];
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> rom_basic[<span class="hljs-number">8</span> * <span class="hljs-number">1024</span>];
    <span class="hljs-keyword">virtual</span> MemoryByte <span class="hljs-keyword">operator</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> address)
    {
        <span class="hljs-function">MemoryByte <span class="hljs-title">mb</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;
        mb.addr = address;
        mb.wptr = ram + address;
        mb.ptr = ram + address;
        <span class="hljs-keyword">switch</span>(address){
            <span class="hljs-keyword">case</span> <span class="hljs-number">0xA000</span> ... <span class="hljs-number">0xBFFF</span>:
                mb.ptr = rom_basic + address - <span class="hljs-number">0xA000</span>;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">0xE000</span> ... <span class="hljs-number">0xFFFF</span>:
                mb.ptr = rom_kernal + address - <span class="hljs-number">0xE000</span>;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">return</span> mb;
    }
    <span class="hljs-comment">//[...]</span>
    C64Memory() : ram{}
    {
        <span class="hljs-comment">//Copy CHRGET</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> src = <span class="hljs-number">0xE3A2</span>, dst = <span class="hljs-number">0x73</span>; src &lt;= <span class="hljs-number">0xE3BE</span>; src++, dst++){
            ram[dst] = (*<span class="hljs-keyword">this</span>)[src];
        }
    }
};
</code><div style="display: none;">
class C64Memory : public Memory
{
	public:
	uint8_t ram[64 * 1024];
	static const uint8_t rom_kernal[8 * 1024];
	static const uint8_t rom_basic[8 * 1024];
	virtual MemoryByte operator[](std::size_t address)
	{
		MemoryByte mb(this);
		mb.addr = address;
		mb.wptr = ram + address;
		mb.ptr = ram + address;
		switch(address){
			case 0xA000 ... 0xBFFF:
				mb.ptr = rom_basic + address - 0xA000;
				break;
			case 0xE000 ... 0xFFFF:
				mb.ptr = rom_kernal + address - 0xE000;
				break;
			default:
				break;
		}
		return mb;
	}
	//[...]
	C64Memory() : ram{}
	{
		//Copy CHRGET
		for(size_t src = 0xE3A2, dst = 0x73; src &lt;= 0xE3BE; src++, dst++){
			ram[dst] = (*this)[src];
		}
	}
};
</div>
<br>
Some small bugs occurred when I called the wrong routine addresses and before I realized I had to copy CHRGET as above.
To debug this, I used <a href="https://vice-emu.sourceforge.io/vice_12.html" target="_top">the VICE emulator&apos;s monitor</a> and modified the 6502 logger to create output in the same style, allowing for easy comparison and quickly finding the divergence point.
<br>
<br>
Then, each operation is done by assembling and running a small 6502 program which calls the Kernal routines:<br>
<code class="cpp" data-hled="true">
C64Float C64Float::<span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> C64Float other) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">size_t</span> addrFAC, addrARG;
    <span class="hljs-keyword">return</span> NewProg()
        .getAddr(addrFAC)
        .pushFloat(*<span class="hljs-keyword">this</span>)
        .getAddr(addrARG)
        .pushFloat(other)
        .begin()
        .pushMOVFM(addrFAC)
        .pushFMUL(addrARG)
        .pushMOVMF(addrFAC)
        .execute()
        .retFloat(addrFAC);
}
</code><div style="display: none;">
C64Float C64Float::operator *(const C64Float other) const
{
	size_t addrFAC, addrARG;
	return NewProg()
		.getAddr(addrFAC)
		.pushFloat(*this)
		.getAddr(addrARG)
		.pushFloat(other)
		.begin()
		.pushMOVFM(addrFAC)
		.pushFMUL(addrARG)
		.pushMOVMF(addrFAC)
		.execute()
		.retFloat(addrFAC);
}
</div>
<br>
&quot;NewProg&quot; is just a convenience function to create new C64Prog class instances. C64Prog has several small methods which are strung together to assemble and execute a 6502 program.<br>
<code class="cpp" data-hled="true">
    C64Prog C64Prog::pushLDA(<span class="hljs-keyword">uint8_t</span> val){    <span class="hljs-keyword">return</span> pushBytes(<span class="hljs-number">0xA9</span>, val); }
    C64Prog C64Prog::pushAddrAY(<span class="hljs-keyword">size_t</span> addr){ <span class="hljs-keyword">return</span> pushLDA(addr &amp; <span class="hljs-number">0xFF</span>u).pushLDY(addr &gt;&gt; <span class="hljs-number">8u</span>); }
    C64Prog C64Prog::pushFMUL(<span class="hljs-keyword">size_t</span> addr){   <span class="hljs-keyword">return</span> pushAddrAY(addr).pushJSR(<span class="hljs-number">0xBA28</span>); }
</code><div style="display: none;">
    C64Prog C64Prog::pushLDA(uint8_t val){    return pushBytes(0xA9, val); }
    C64Prog C64Prog::pushAddrAY(size_t addr){ return pushLDA(addr &amp; 0xFFu).pushLDY(addr &gt;&gt; 8u); }
    C64Prog C64Prog::pushFMUL(size_t addr){   return pushAddrAY(addr).pushJSR(0xBA28); }
</div>
<br>
Here, the magic constant 0xBA28 is the address of the kernal routine we want, which can be looked up in a Commodore 64 reference.<br><br>
Each C64Float goes in and out as 5 bytes:<br>
<code class="cpp" data-hled="true">
C64Prog C64Prog::pushFloat(<span class="hljs-keyword">const</span> C64Float f)
{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(f.val); i++){
        pushBytes(f.val[i]);
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
C64Prog C64Prog::popFloat(<span class="hljs-keyword">size_t</span> addr, C64Float &amp;f)
{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(f.val); i++){
        f.val[i] = ram[addr + i];
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
C64Float C64Prog::retFloat(<span class="hljs-keyword">size_t</span> addr)
{
    C64Float f;
    popFloat(addr, f);
    <span class="hljs-keyword">return</span> f;
}
</code><div style="display: none;">
C64Prog C64Prog::pushFloat(const C64Float f)
{
    for(size_t i = 0; i &lt; sizeof(f.val); i++){
        pushBytes(f.val[i]);
    }
    return *this;
}
C64Prog C64Prog::popFloat(size_t addr, C64Float &amp;f)
{
    for(size_t i = 0; i &lt; sizeof(f.val); i++){
        f.val[i] = ram[addr + i];
    }
    return *this;
}
C64Float C64Prog::retFloat(size_t addr)
{
    C64Float f;
    popFloat(addr, f);
    return f;
}
</div>
<br>
Those 5 bytes consist of an 8bit exponent, a 31bit mantissa and a sign bit, allowing the following conversion to regular floating point:<br>
<code class="cpp" data-hled="true">
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">C64FloatToDouble</span><span class="hljs-params">(C64Float f)</span>
</span>{
    <span class="hljs-keyword">if</span>(!f.val[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mantissa =
        (((f.val[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x7F</span>) | <span class="hljs-number">0x80</span>u) &lt;&lt; <span class="hljs-number">24</span>) +
        (f.val[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) +
        (f.val[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) +
        (f.val[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = f.val[<span class="hljs-number">0</span>];
    <span class="hljs-built_in">exp</span> -= <span class="hljs-number">0x81</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, <span class="hljs-built_in">exp</span>) * <span class="hljs-keyword">double</span>(mantissa) / <span class="hljs-keyword">double</span>(<span class="hljs-number">0x80</span>u &lt;&lt; <span class="hljs-number">24</span>);
}
</code><div style="display: none;">
double C64FloatToDouble(C64Float f)
{
	if(!f.val[0]) return 0.0;
	unsigned int mantissa =
		(((f.val[1] &amp; 0x7F) | 0x80u) &lt;&lt; 24) +
		(f.val[2] &lt;&lt; 16) +
		(f.val[3] &lt;&lt; 8) +
		(f.val[4] &lt;&lt; 0);
	int exp = f.val[0];
	exp -= 0x81;
	return std::pow(2.0, exp) * double(mantissa) / double(0x80u &lt;&lt; 24);
}
</div>
<br>
<h2>Performance and accuracy</h2>
The performance obviously is piss-poor. The mandelbrot code, the same unoptimized one from <a href="index_gifcap.html" target="_top">the gifcap demo</a>, pushes it to its limits:<br>
<code class="cpp" data-hled="true">
<span class="hljs-keyword">for</span>(iY=<span class="hljs-number">0</span>;iY&lt;iYmax;iY++){
    Cy=CyMin + floatType(iY) *PixelHeight;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(Cy)&lt; PixelHeight/floatType(<span class="hljs-number">2</span>)) Cy=f0; <span class="hljs-comment">/* Main antenna */</span>
    <span class="hljs-keyword">for</span>(iX=<span class="hljs-number">0</span>,Cx=CxMin;iX&lt;iXmax;iX++,Cx+=PixelWidth){
        <span class="hljs-comment">/* initial value of orbit = critical point Z= 0 */</span>
        Zx=f0;
        Zy=f0;
        Zx2=Zx*Zx;
        Zy2=Zy*Zy;
        <span class="hljs-comment">/* */</span>
        <span class="hljs-keyword">for</span>(Iteration=<span class="hljs-number">0</span>;Iteration&lt;IterationMax &amp;&amp; ((Zx2+Zy2)&lt;ER2);Iteration++){
            Zy=f2*Zx*Zy + Cy;
            Zx=Zx2-Zy2 +Cx;
            Zx2=Zx*Zx;
            Zy2=Zy*Zy;
        };
        PutPixel(bmp, iX, iY, CalcColor(Iteration));
    }
}
</code><div style="display: none;">
for(iY=0;iY&lt;iYmax;iY++){
    Cy=CyMin + floatType(iY) *PixelHeight;
    if(abs(Cy)&lt; PixelHeight/floatType(2)) Cy=f0; /* Main antenna */
    for(iX=0,Cx=CxMin;iX&lt;iXmax;iX++,Cx+=PixelWidth){
        /* initial value of orbit = critical point Z= 0 */
        Zx=f0;
        Zy=f0;
        Zx2=Zx*Zx;
        Zy2=Zy*Zy;
        /* */
        for(Iteration=0;Iteration&lt;IterationMax &amp;&amp; ((Zx2+Zy2)&lt;ER2);Iteration++){
            Zy=f2*Zx*Zy + Cy;
            Zx=Zx2-Zy2 +Cx;
            Zx2=Zx*Zx;
            Zy2=Zy*Zy;
        };
        PutPixel(bmp, iX, iY, CalcColor(Iteration));
    }
}
</div>
<br>
It took 34 minutes to render the 600x450 image above this article, by emulating 27460104375 machine cycles of the 6502.
That would take 7 hours and a half in a real life Commodore 64.
Even though I limited the max iterations to a mere 25.<br>
<br>
The floating-point accuracy, in this and other tests, is shown to be quite good.
Comparing to a regular &quot;double&quot; version of the code, the only change is in images with odd dimensions where the centre line will evaluate slightly different:<br>
<img src="images/mandelbrot_c64_20x15.gif"><img src="images/mandelbrot_c64_60x45.gif"><br><br>
In other tests, I find the most inaccurate operation seems to be the multiplication.
Overall the accuracy is much like a regular double and way better than a float, as expected from the 31bit mantissa of the format.<br>
<h2>Acknowledgments</h2>
The following resources were extremely useful when making this:<br>
<ul>
<li><a href="https://www.c64-wiki.com/wiki/Floating_point_arithmetic" target="_top">Floating Point Arithmetic</a> on the C64-Wiki</li>
<li><a href="https://codebase64.org/doku.php?id=base:kernal_floating_point_mathematics" target="_top">Floating Point Math</a> page from Codebase64</li>
<li><a href="https://www.pagetable.com/c64ref/c64disasm/" target="_top">C64 BASIC &amp; KERNAL ROM Disassembly</a> - Commented and explained</li>
</ul>
</body></html>