<html><head data-created="2019-11-19T06:06:34.309Z" data-modified="2019-11-19T06:04:59.477Z"><meta charset="UTF8"><link rel="stylesheet" href="hlstyles/default.css"><link rel="stylesheet" href="motherfucker.css"></head><body data-title="NES Emulation Saga Part III"><div class="article-index"><ul data-type="pages_index"><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem3.html">NES Emulation Saga Part III</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem2.html">NES Emulation Saga Part II</a></li><li><span>&apos;19/11/19 06:06   </span><a target="_top" href="index_nesem1.html">NES Emulation Saga Part I</a></li><li><span>&apos;19/10/31 02:37   </span><a target="_top" href="index_kym.html">&#x1F3AE; Kori Yogan Mushi</a></li><li><span>&apos;19/08/03 20:43   </span><a target="_top" href="index_bespoke.html">&#x1F3AE; Bespoke Terror</a></li><li><span>&apos;19/08/03 20:32   </span><a target="_top" href="index_1hgj8.html">&#x1F3AE; Conker&apos;s BFD for Nintendo 486</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_trog.html">&#x1F3AE; TROG</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_stacker.html">&#x1F3AE; TTY Stacker</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_snake.html">&#x1F3AE; Snake</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_sm64.html">&#x1F3AE; SM64 HTML5</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_ronaldo.html">&#x1F3AE; 3D Ronaldo Football</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_roguelike.html">&#x1F3AE; Batch Roguelike</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_prototype.html">&#x1F3AE; Prototype</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_nestest.html">&#x1F3AE; NEStest</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_megamanblue.html">&#x1F3AE; MegaMan in the blue mountains</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD36.html">&#x1F3AE; Rune Stacker</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD31.html">&#x1F3AE; Doktornix And The Fetch Quest</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD29warmup.html">&#x1F3AE; Ludum Dare 29 Warmup</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD29.html">&#x1F3AE; Ground control to Major Tomashevsky</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD23warmup.html">&#x1F3AE; Ludum Dare 23 Warmup</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_LD23.html">&#x1F3AE; Ludum Dare 23</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_keystone.html">&#x1F3AE; Keystone Kapers for NES</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_gbmine.html">&#x1F3AE; GBMINE</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_choplifter.html">&#x1F3AE; Choplifter</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_breakout.html">&#x1F3AE; 6502 breakout</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_alibaba.html">&#x1F3AE; Ali Baba and the 40 thieves</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj6.html">&#x1F3AE; 1HGJ6</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj5.html">&#x1F3AE; 1HGJ5</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj4.html">&#x1F3AE; 1HGJ4</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hgj3.html">&#x1F3AE; 1HGJ3</a></li><li><span>&apos;19/07/23 22:18   </span><a target="_top" href="index_1hg7.html">&#x1F3AE; 1HGJ7</a></li></ul></div>
<h1>NES Emulation Saga - Writing a NES emulator
Part III: the APU</h1>

This is a series <a href="index_nesem1.html" target="_top">(part1, </a><a href="index_nesem2.html" target="_top"> part2)</a> of articles on the development of my own NES emulator.
It is coded in a mixture of C/C++, using Allegro 4, and is hosted at bitbucket <a href="https://bitbucket.org/kdrnic/nesem/src/master/" target="_top">
(link to repository)</a>.<br><br>

The APU is NES&apos; Audio Processing Unit. It has a very characteristic sound.<br>
Here is a sample of my emulation of it, featuring Journey to Silius&apos; famous opening theme:
<video controls height="256">
    <source src="files/JTS.mp4" type="video/mp4">
    Sorry, your browser sucks balls.
</video><br><br>

The APU has the following:
<ul>
<li>Square wave (pulse) 1 channel</li>
<li>Square wave (pulse) 2 channel</li>
<li>Triangle wave channel</li>
<li>Noise generator channel</li>
<li>Differential pulse-code modulation (DCM) sample playback channel</li>
<li>Envelope generator for the pulse and noise channels</li>
<li>Length counter for all channels</li>
<li>Sweep generator for the pulse channels</li>
<li>Fancy non-linear mixing, sort of by accident</li>
</ul>

A <a href="https://wiki.nesdev.com/w/index.php/APU" target="_top">more detailed explanation is available at the NESDev
wiki</a>, and here I will focus on the issues I met.<br><br>

<h1>VGM file format</h1>

I (correctly) predicted that emulating both the CPU/APU interface and the audio synthesis together would be challenging,
so I employed divide-and-conquer and tackled the latter first. As
<a href="https://www.reddit.com/r/arduino/comments/9o5scz/8bit_nes_music_emulated_on_esp32/" target="_top">this ESP232-based NES song player</a>
<a href="https://web.archive.org/web/20191119052847/https://www.reddit.com/r/arduino/comments/9o5scz/8bit_nes_music_emulated_on_esp32/" target="_top">
(archive)</a> <a href="https://github.com/connornishijima/Cartridge" target="_top">(source code)</a> I found in a preliminary Google search had done,
I opted to make use of VGM format music rips. Those are timed logs of register writes, which are much more approachable.<br><br>

I fetched VGM packs from Super Mario Bros., Castlevania, Rockman, and Journey to Silius, which together form a very representative sample
of the great NES sound. Unzipped, the files were all .VGZ, so gzip-compressed. I could&apos;ve used a bash script to pass them all through gzip,
but I opted to put together zlib code to decompress the files in memory with the help of <a href="https://www.lemoda.net/c/zlib-open-read/" target="_top">
this example code</a> <a href="https://web.archive.org/web/20191119053804/https://www.lemoda.net/c/zlib-open-read/" target="_top">(archive)</a>.<br><br>

That done, <a href="https://vgmrips.net/wiki/VGM_Specification" target="_top">the VGM specification</a> was simple to follow and only a few commands needed
for the NES files I had.<br><br>

Together with direct audio output, I also implemented an oscilloscope view and an option to record to a .WAV file. Inspecting the waveforms both
in real time and with Audacity was of good help.<br><br>

The VGM player has its own repository at bitbucket <a href="https://bitbucket.org/kdrnic/nes_vgm_player/src/master/" target="_top">here</a>.<br><br>

Now for synthesis details.<br><br>

<h1>Aliasing annoyance</h1>

Back in <a href="https://mitxela.com/projects/swotGB/about" target="_top">mitxela&apos;s post that started it all</a>
<a href="https://web.archive.org/web/20191119022334/https://mitxela.com/projects/swotGB/about" target="_top">(archive)</a>,
he said:<br><br>

<i>&quot;Sound is supposed to be the hardest part to emulate. I think this is mostly because if you&apos;re not familiar with Nyquist aliasing,
 square waves sound easy, until you hear them, and they sound terrible.&quot;</i><br><br>
 
I knew although rather roughly the implications of the theorem, and thus already feared from the outset this task. mitxela proceeded to describe
how easy he had it with the synthesis tools in the WebAudio API. In my case, the API I have is a buffer of uint16_t which my code must fill,
so the challenge is increased.<br><br>

For a tl;dr, the way aliasing works is that a frequency above half the sampling rate (&quot;above the Nyquist&quot;) ends up present in the sampled signal,
but looking indistinguishable from (&quot;aliasing&quot;) a lower frequency:<br>
<a href="https://commons.wikimedia.org/wiki/File:AliasingSines.svg" target="_top"
title="A graph showing aliasing of an f=0.9 sine wave by an f=0.1 sine wave by sampling at a period of T=1.0"><img src="images/nesem14.png"
alt="A graph showing aliasing of an f=0.9 sine wave by an f=0.1 sine wave by sampling at a period of T=1.0"></a><br><br>

Precisely, the <i>&quot;aliased frequency is the absolute difference between the actual signal frequency and the nearest integer multiple of the sampling
frequency&quot;</i>. Together with the formula discussed below for the harmonic series of a rectangle wave, I put up
<a href="https://docs.google.com/spreadsheets/d/1B3-rHWkQr1JitDHtQH9h6ZG1ybv1S4rw7HpRQP67tpI/edit#gid=1045095700" target="_top">this spreadsheet</a>
from which one can see the strength and position of aliased frequencies. Even the 100th term is contributing as much as 1% of the 1st, despite being aliased
to Hell and back, so the square wave is indeed challenging.<br><br>

<h1>Additive synthesis</h1>

My first idea to avoid aliasing was to emulate what mitxela did, but without the magic from WebAudio createPeriodicWaveform - i.e. express each waveform
as a sum of sine waves, cutting off those with a frequency higher than half the sampling frequency, thus producing perfect band-limited
square or triangle waves. Other than mitxela&apos;s own maths, I also found <a href="https://lpsa.swarthmore.edu/Fourier/Series/ExFS.html" target="_top">a 
 good reference for the Fourier terms</a><a href="https://web.archive.org/web/20191119044314/https://lpsa.swarthmore.edu/Fourier/Series/ExFS.html" target="_top">
(archive)</a> belonging to some course on Fourier analysis. I found others, but the formulas were not as well explained or so succinctly.<br><br>

This is what the code for the square wave ended up like, simplified for clarity:
<code class="cpp" data-hled="true"><span class="hljs-keyword">double</span> time_multiplier = <span class="hljs-number">2</span> * pi / <span class="hljs-number">44100.0</span>;
<span class="hljs-comment">/*
Duty cycle is as such:
0 - 12.5%		
1 - 25%			
2 - 50%			
3 - 75% i.e. 25% but upside down
*/</span>
<span class="hljs-keyword">int</span> sq_duty_tbl2[<span class="hljs-number">4</span>] = {<span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>};
<span class="hljs-keyword">double</span> sq_duty_tbl[<span class="hljs-number">4</span>] = {<span class="hljs-number">0.125</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>};
sq_time += sq_freq;
<span class="hljs-comment">//Synthesize band limited square wave</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>; sq_freq * n &lt; <span class="hljs-number">44100</span> / <span class="hljs-number">2</span>; n++){
    <span class="hljs-keyword">double</span> An = <span class="hljs-number">2</span> * <span class="hljs-built_in">sin</span>(n * pi * sq_duty_tbl[sq_duty]) / (n * pi);
    <span class="hljs-keyword">if</span>(n % sq_duty_tbl2[sq_duty] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
    
    sq_ampl += <span class="hljs-built_in">cos</span>(sq_time * n) * An;
}
<span class="hljs-comment">//Normalize to 0.0-1.0 range (although Gibbs&apos; phenomenon exceeds the interval)</span>
sq_ampl += sq_duty_tbl[sq_duty];
</code><div style="display: none;">
double time_multiplier = 2 * pi / 44100.0;
/*
Duty cycle is as such:
0 - 12.5%		
1 - 25%			
2 - 50%			
3 - 75% i.e. 25% but upside down
*/
int sq_duty_tbl2[4] = {8, 4, 2, 4};
double sq_duty_tbl[4] = {0.125, 0.25, 0.5, 0.25};
sq_time += sq_freq;
//Synthesize band limited square wave
for(int n = 1; sq_freq * n &lt; 44100 / 2; n++){
	double An = 2 * sin(n * pi * sq_duty_tbl[sq_duty]) / (n * pi);
	if(n % sq_duty_tbl2[sq_duty] == 0) continue;
	
	sq_ampl += cos(sq_time * n) * An;
}
//Normalize to 0.0-1.0 range (although Gibbs&apos; phenomenon exceeds the interval)
sq_ampl += sq_duty_tbl[sq_duty];
</div><br><br>

And the simpler still code for the triangle wave. The NES doesn&apos;t actually generate a pretty triangle wave,
the one it got has visible steps since it has only 4 bits of resolution. However, I actually preferred the sound of a real triangle wave,
and it was simpler to additive-synthesize.
<code class="cpp" data-hled="true">tri_time += tri_freq;
<span class="hljs-comment">////Synthesize band limited triangle wave</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; tri_freq * n &lt; <span class="hljs-number">44100</span> / <span class="hljs-number">2</span>; n++){
    <span class="hljs-keyword">if</span>((n % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">double</span> An = (<span class="hljs-number">1.0</span> - <span class="hljs-built_in">pow</span>(<span class="hljs-number">-1</span>, n)) / (<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">2.0</span>) * <span class="hljs-built_in">pow</span>(pi, <span class="hljs-number">2.0</span>));
    tri_ampl += <span class="hljs-built_in">cos</span>(tri_time * n) * An;
}
<span class="hljs-comment">//Normalize to 0.0-1.0 range</span>
tri_ampl += <span class="hljs-number">0.25</span>;
tri_ampl *= <span class="hljs-number">2.0</span>;
</code><div style="display: none;">
tri_time += tri_freq;
////Synthesize band limited triangle wave
for(int n = 0; tri_freq * n &lt; 44100 / 2; n++){
	if((n % 2) == 0) continue;
	double An = (1.0 - pow(-1, n)) / (pow(n, 2.0) * pow(pi, 2.0));
	tri_ampl += cos(tri_time * n) * An;
}
//Normalize to 0.0-1.0 range
tri_ampl += 0.25;
tri_ampl *= 2.0;
</div><br><br>

I didn&apos;t at this point make an attempt to synthesize bandlimited noise or to fix the (much smaller in amplitude) aliasing from DPCM playback.<br><br>

The main issue with this approach was that it is slow. The audio would glitch and pop as it could not keep up with real time
playback, and on top of CPU emulation it left the emulator extremely laggy.<br><br>

A profiling log generated with the <a href="https://github.com/VerySleepy/verysleepy" target="_top">VerySleepy profiler</a> shows that as expected most time
was being spent in the inner sine summation loops.<br><br>

First, I changed the code to avoid integer to floating point conversions, with some small improvement. Next, I stored a precalculated table of the An series
of coefficients, without dramatic improvement.<br><br>

I started looking into fancier ways to generate the waveforms, like using a full DCT algorithm or keeping tables of pre-synthesized waves. I tried getting
gcc to emit raw x87 fsin and fcos instructions, which it avoids 
<a href="https://randomascii.wordpress.com/2014/10/09/intel-underestimates-error-bounds-by-1-3-quintillion/" target="_top">because they are very inaccurate in
certain situations</a> <a href="https://web.archive.org/web/20191120225130/https://randomascii.wordpress.com/2014/10/09/intel-underestimates-error-bounds-by-1-3-quintillion/" target="_top">
(archive)</a>, to no success, even with -O3 -ffast-math it still did that dreaded call sin, call cos. I was looking at some optimised ways to calculate
those functions, with many suggesting lookup tables or Taylor series. But there was a mention of generating co/sine series using those classic school 
trigonometry equations:
<code class="plaintext" data-hled="true">sin(x+y)=sin(x)cos(y)+cos(x)sin(y)
cos(x+y)=cos(x)cos(y)-sin(x)sin(y)
</code><div style="display: none;">sin(x+y)=sin(x)cos(y)+cos(x)sin(y)
cos(x+y)=cos(x)cos(y)-sin(x)sin(y)
</div>
and plugging those into code allowed me to reduce the sin and cos calls to 2 per waveform sample:
<code class="cpp" data-hled="true"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>
    sin_time = <span class="hljs-built_in">sin</span>(sq_time),
    cos_time = <span class="hljs-built_in">cos</span>(sq_time);
<span class="hljs-keyword">double</span> temp, sin_n, cos_n;
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">1</span>,
    sin_n = sin_time,
    cos_n = cos_time;
    sq_freq * n &lt; <span class="hljs-number">22050</span>;
    n++,
    temp = sin_n * cos_time + cos_n * sin_time,
    cos_n = cos_n * cos_time - sin_n * sin_time,
    sin_n = temp
){
    <span class="hljs-comment">//Get coeff from precalculated table</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> an = sq_an[n];
    sq_ampl += cos_n * an;
}
</code><div style="display: none;">const double
	sin_time = sin(sq_time),
	cos_time = cos(sq_time);
double temp, sin_n, cos_n;
int n;
for(n = 1,
	sin_n = sin_time,
	cos_n = cos_time;
	sq_freq * n &lt; 22050;
	n++,
	temp = sin_n * cos_time + cos_n * sin_time,
	cos_n = cos_n * cos_time - sin_n * sin_time,
	sin_n = temp
){
    //Get coeff from precalculated table
	const double an = sq_an[n];
	sq_ampl += cos_n * an;
}
</div><br>

I was happy to verify, in a series of Very Sleepy profiling logs, that the time taken by the inner loops now was under 25% of the baseline. I also
felt like a fool for not thinking of this before.<br><br>

<h1>A comparison</h1>

I threw together a quick ROM to play chromatic scales from highest to lowest octaves, to compare the resulting sound:
<code class="plaintext" data-hled="true">inc noteCounter
    bne ++
    dec note
    bpl +
    lda #79
    sta note
+	ldy note
    lda #00000001b	; Enable square 1
    sta $4015
    lda #10111111b ; Constant full volume, halt length counter, 50% duty
    sta $4000
    lda periodTableLo,y	; Period low bits
    sta $4002
    lda periodTableHi,y	; Period high bits
    sta $4003
++
</code><div style="display: none;">
	inc noteCounter
	bne ++
	dec note
	bpl +
	lda #79
	sta note
+	ldy note
	lda #00000001b	; Enable square 1
	sta $4015
	lda #10111111b ; Constant full volume, halt length counter, 50% duty
	sta $4000
	lda periodTableLo,y	; Period low bits
	sta $4002
	lda periodTableHi,y	; Period high bits
	sta $4003
++
</div><br><br>

I then did recordings in Nestopia, FCEUX and my own emulator, and loaded them up in Audacity, and used the spectrogram view. It is very telling.
From top to bottom, FCEUX, &quot;kdrNES&quot; with (slow) additive synthesis, kdrNES using the cosine series (of course identical), kdrNES with naive
aliased square wave synthesis, and Nestopia.
<img src="images/nesem12.png"><br><br>

kdrNES with additive synthesis does well, placing between FCEUX and Nestopia in terms of cleanness between harmonics.<br><br>

As expected from the spreadsheet calculations, the naive method is full of ghost frequencies in all ranges, and the spectrogram is painted red with them
except for the few gaps where note periods must be an integer factor of the sampling frequency.<br><br>

<h1>Low-pass filter</h1>

The NES at least in effect seems to have a low-pass filter at 14kHz.<br><br>

I opted for a FIR (Finite Impulse Response) over an IIR (Infinite Impulse Response) filter due to believing it would have better phase
characteristics.<br><br>

I am only familiar with FIR (and DSP lingo in general) from implementing image scaling, where a Mitchell-Netravali or Lanczos filter is a good
standard and the formula for it is simple to turn into a convolution matrix. This though requires a custom filter, and Googling how to calculate
the coefficients for a filter turns up DSP tutorials and introductory theory involving ideal sinc filters. Googling &quot;fir filter design tools&quot;
had more success, and I found the <a href="http://www.iowahills.com/5FIRFiltersPage.html" target="_top">Iowa Hills FIR Filter design tool</a>
<a href="https://web.archive.org/web/20191119045629/http://www.iowahills.com/5FIRFiltersPage.html" target="_top">(archive)</a>. It was relatively straightforward
to use and generates the coefficients as a .TXT file.<br><br>

I designed a low-pass filter with the Kaiser method as it was highly praised, and set it for minimum phase as we don&apos;t want to mess with the timing
of the game sounds. With the desired frequency cutoff of 14kHz. I arbitrarily picked 63 taps.<br><br>

<img src="images/nesem10.png"><br><br>

<h1>Emulator integration</h1>

In the NES the APU runs at 1.79 MHz together with the CPU. My APU runs at 44.1kHz, even the logic, which will have timings off of course but is enough
 for a low accuracy emulator. It of course won&apos;t allow for games that use the APU to time raster chasing tricks, which are only a few.<br><br>

My approach was to keep a CPU cycles counter, and on every APU register access, before completing the read or write, convert those to an equivalent
number of 44.1kHz cycles and run the APU, which updates the registers and also buffers the next samples to be played. I keep two copies of the APU
registers, since some are used for other things like joystick reading, and have to copy them to and fro.
<code class="cpp" data-hled="true"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SyncAPU</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> sync_regs = <span class="hljs-literal">true</span>)</span>
</span>{
    <span class="hljs-keyword">if</span>(sync_regs){
        <span class="hljs-built_in">memcpy</span>(apu_state.regs, apu, <span class="hljs-keyword">sizeof</span>(apu));
        <span class="hljs-built_in">memcpy</span>(apu_state.reg_w, apu_w, <span class="hljs-keyword">sizeof</span>(apu));
    }
    <span class="hljs-keyword">int</span> nsamples = (apuCycles * <span class="hljs-number">44100</span>) / apu_state.clock;
    nsamples = apu_sample(&amp;apu_state, &amp;ptrSampled, ptrSampled + nsamples, nsamples);
    apuCycles -= (nsamples * apu_state.clock) / <span class="hljs-number">44100</span>;
    
    <span class="hljs-built_in">memcpy</span>(apu, apu_state.regs, <span class="hljs-keyword">sizeof</span>(apu));
    <span class="hljs-built_in">memcpy</span>(apu_w, apu_state.reg_w, <span class="hljs-keyword">sizeof</span>(apu));
}
</code><div style="display: none;">
void SyncAPU(bool sync_regs = true)
{
    if(sync_regs){
        memcpy(apu_state.regs, apu, sizeof(apu));
        memcpy(apu_state.reg_w, apu_w, sizeof(apu));
    }
    int nsamples = (apuCycles * 44100) / apu_state.clock;
    nsamples = apu_sample(&amp;apu_state, &amp;ptrSampled, ptrSampled + nsamples, nsamples);
    apuCycles -= (nsamples * apu_state.clock) / 44100;
    
    memcpy(apu, apu_state.regs, sizeof(apu));
    memcpy(apu_w, apu_state.reg_w, sizeof(apu));
}
</div><br><br>

<h1>Bugs of note</h1>

While playing music alone with the VGM Player it wasn&apos;t ever obvious, likely because the square channels would play notes similar to each other,
but once integrated with the emulator and the games would have sound effects sharing the channels (usually the 1st) and interrupting notes
of the music, there was a clear glitching of the volume envelopes. Turned out I forgot to index by channel number and used the first channel envelope
for both:<br><br>

<img src="images/nesem11.png"><br><br>

<h1>Conclusion</h1>

The divide-and-conquer develop the APU separate from the rest through VGM was a very effective approach and reduced frustration from bugs, while also
allowing high quality test material from the beginning.<br>
Sticking to additive synthesis paid out in the end. It remains more CPU-intensive than methods such as wavetables and the gold standard in NES emulation that
is <a href="http://blargg.8bitalley.com/bl-synth/10.bl_step_diffs.html" target="_top">BLEP</a>, but it is conceptually simple and doesn&apos;t obfuscate the sampler&apos;s working,
so I feel stubbornly validated.<br>

</body></html>