<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!--

INFINITE MAZER
This file contains a game. Improve it, and publish it to https://openfu.com/ld/codepong/ for the next person to pick up!

WISHLIST
  - combat system

--><style>
    *,
    *:before,
    *:after {
        box-sizing: border-box;
        font-size: inherit;
        font-family: inherit;
    }

    body {
        background: black;
        color: white;
        margin: 0;
        padding: 0;
        margin: auto;
        margin-top: 16px;
        font-size: 12px;
        font-family: monospace;
        line-height: 1.0;
        overflow: hidden;
    }

    body>div {
        margin: 16px 0;
    }

    button {
        padding: 8px;
        background: rgba(100, 100, 100, 0.5);
        border: 1px solid rgba(100, 100, 100, 0.5);
        color: gray;
        min-width: 140px;
        cursor: pointer;
        margin: 4px;
    }

    button:hover {
        color: cyan;
    }

    canvas {
        background: #111;
        border: 1px solid rgba(100,100,100,0.5);
    }
    
    #textLog > div {
        padding: 4px;
        white-space: pre-wrap;
    }
    
    #textLogScrollPane {
        height: 480px;
        overflow: auto;
        border: 1px solid rgba(100,100,100,0.5);
    }
    
    .cursor {
        display: inline-block;
        width: 12px;
        height: 20px;
        background: white;
    }
    
    .cursor, .prompt_text {
        vertical-align: middle;
    }
    
    .stat-section {
        border: 1px solid rgba(100,100,100,0.25);
        background: rgba(100,100,100,0.25);
    }
    
    .stat-section > div {
        padding: 4px;
    }
    
    .linediv {
      display: flex;
    }
    .linediv > * {
      flex: 1;
    }    
    .linediv > .name {
      max-width: 64px;
      text-align: right;
    }

    .content {
        background: black;
    }
    
    #actionDiv {
        position: absolute;
        left: 0; right: 0; bottom: 0; height: auto; 
    }

    </style>
</head>

<body>
    <div style="display:flex;">
      <div style="flex:1;min-width:300px;max-width:400px;overflow-y:auto;">
         <div id="playerStats"></div>
      </div>
        <div style="flex:2;" id="map-pane">
            <canvas id="canvas" width="480" height="480"></canvas>
        </div>
        <div id="textLogScrollPane" style="flex:2;">
          <div id="textLog">
             <div>You're in a maze of twisty little passages, all alike.</div>
          </div>
          <div>
              <span id="prompt_text"></span>
              <span class="cursor"></span>
          </div>
        </div>
    </div>
    
    <div id="actionDiv">
        What do you want to do?
        <div id="buttonsDiv">

        </div>
    </div>
    <script>
    
    var display = {
      columns : 480 / 32, 
      rows : 480 / 32,
      tileSize : 32, // 32 pixels per tile
      canvas : {},
      context : {},
    }
    
    var player = {};
    var dungeon = [{}];
    
    /* ------------------------ UTILITY FUNCTIONS -------------------------- */
  
    function clamp(value, min, max) {
        if(value < min) value = min;
        if(value > max) value = max;
        return(value);
    }
  
    function distance(x1, y1, x2, y2) {
        var xd = x1 - x2;
        var yd = y1 - y2;
        return(Math.sqrt(
            xd*xd + yd*yd
            ));
    }
    
    function dice(n,s){
        var t = 0;
        for(var i = 0; i < n; i++){
            t += Math.ceil(Math.random() * s);
        }
        return t;
    }
    
    function lineEach(x0, y0, x1, y1, f) {
        var dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        var dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1; 
        var err = (dx>dy ? dx : -dy)/2;
        while (true) {
            f(x0, y0);
            if (x0 === x1 && y0 === y1) break;
            var e2 = err;
            if (e2 > -dx) { err -= dy; x0 += sx; }
            if (e2 < dy) { err += dx; y0 += sy; }
        }
    }
    
    function getName(entity, optionalArticle) {
        if (entity == player)
            return('you');
        var name = entity.name || 'thing';
        if(typeof entity.prefix !== 'undefined')
            name = entity.prefix + name;
        else 
            name = (optionalArticle || 'the ')+name;
        return(name);
    }
    
    function getSubjectAndVerb(entity, verb) {
        if(entity != player)
            verb = verb + 's';
        return(getName(entity)+' '+verb);
    }
    
    function selectRandom(fromList) {
        if(!fromList || fromList.length == 0) return;
        return(fromList[Math.floor(Math.random()*fromList.length)]);
    }
    
    function cloneOrMerge(sourceObject, optionalDestination) {
        var c = optionalDestination || {};
        for(var prop in sourceObject) { 
            var value = sourceObject[prop];
            if(typeof value == 'function')
                c[prop] = value.bind(c);
            else
                c[prop] = value;
        }
        return(c);
    }
    
    function each(o, f) {
        if(!o) return;
        for(var prop in o) f(o[prop], prop);
    }
    
    function capitalize(s) {
        return(s.substr(0, 1).toUpperCase() + s.substr(1));      
    }

    /* ------------------------ GENERATORS -------------------------- */
    
    var creatureTemplates = {
      
        player : {
            nospawn : true,
            x: 0,
            y: 0,
            symbol: "@",
            floor: 0, // 0 is ground floor, only way is down
            name: "player",
            maxHealth: 10,
            accuracy : 1.0, // optional, defaults to 1
            slots : {
              weapon : false,
              armor : false,
              belt : false,
              finger1: null,
              finger2: null,
              neck: null
            },
            inventory : {},
            maxInventory : 15,
            inventoryCount : 0,
            lightRadius : 2,
        },
      
        stint : {
            type: 'storyteller',
            maxHealth: 10,
            symbol: "h",
            prefix : '',
            name: 'Stint McGrath',
            weight: 60.0,
            onTick: function(){
                if(AI.playerCanSee(this)) {
                    if(dice(1, 6) > 4) textLog(getName(this) + " says 'Hey mate'");
                }
            },
            onDeath : function() {
                textLog(getName(this) + " says 'Why...?'");
            },
        },
        
        generico : {
            type: "generic enemy",
            maxHealth: 2,
            symbol: "g",
            prefix: "",
            name: "Generico Enemicio",
            weight: 70,
            awake: false,
            onSpawn : function() {
              this.maxHealth = dice(1, 3);
            },
            onTick: function(){
                this.awake = AI.playerCanSee(this);
                if(this.awake) AI.pursueAndAttack(this, player);
            },
            onDeath: function(){
                textLog(getName(this) + " lets out a Wilhelm scream");
            }
        },
      
    };
    
    var creatureTemplateList = [];
    for(var creatureḰey in creatureTemplates) if(!creatureTemplates[creatureḰey].nospawn)
      creatureTemplateList.push(creatureTemplates[creatureḰey]);
    
    function generateCreature(optionalKey) {
        var template = optionalKey ? creatureTemplates[optionalKey] : selectRandom(creatureTemplateList);
        var creature = cloneOrMerge(template);
        if(creature.onSpawn) creature.onSpawn();
        creature.health = creature.maxHealth;
        return creature;
    }
    
    var itemTemplates = {
      
        rock : {
            type: 'misc',
            name: 'hunk of rock',
            weight: 1.0,
            onEat: function() { textLog("Not very tasty."); }
        },
        amulet_of_nothing : {
            type: "jewelllery",
            name: "amulet of nothing at all",
            jewelSlot: "neck",
            weight: 0.5
        },
        flannel : {
            type: "armor",
            name: "flannel shirt",
            weight: 0.5,
            ac: 0.1, // AC * enemy.accuracy <= Math.random() is the chance this armor will work
            absorption : 1.0, // optional, defaults to 1.0, which means absorb 100% of the damage 
            ec: 10
        },
        ring_of_light : {
            type: "jewelllery",
            name: "ring of light",
            jewelSlot: "finger",
            weight: 0.1,
            onPut: function() { player.lightRadius += 2; },
            onRemove: function() { player.lightRadius -= 2; }
        },
        ring_of_confusion : {
            type: "jewelllery",
            name: "ring of confusion",
            jewelSlot: "finger",
            weight: 0.1,
            onTick: function() { player.confusion = 10; }
        }
        
    };
    
    var itemTemplateList = [];
    for(var itemKey in itemTemplates) if(!itemTemplates[itemKey].nospawn)
      itemTemplateList.push(itemTemplates[itemKey]);

    function generateItem(optionalKey) {
        var template = optionalKey ? itemTemplates[optionalKey] : selectRandom(itemTemplateList);
        var item = cloneOrMerge(template);
        if(item.onSpawn) item.onSpawn();
        item.cursed = dice(1, 6) < 2;
        return item;
    }
    
    function generateFloor(n) {
        var f = (dungeon[n] = {});
        // size of floor
        var w = 15//21//15 + dice(2, 6);
        var h = 15 + dice(2, 6);
        //offset
        var offX = -Math.floor(w / 2);
        var offY = -Math.floor(h / 2);
        //number of walls and items
        var numWalls = 10 + dice(1, 6);
        var numItems = dice(1, 20);
        var numNPCs = 2 + dice(1, 6);
        
        //start as a rectangular walled area
        for(var y = 0; y < h; y++){
            f[y + offY] = {};
            for(var x = 0; x < w; x++){
                f[y + offY][x + offX] = {type: '.' };
            }
            f[y + offY][0 + offX] = {type: '#' };
            f[y + offY][(w - 1) + offX] = {type: '#' };
        }
        for(var x = 0; x < w; x++){
            f[0 + offY][x + offX] = {type: '#' };
            f[(h - 1) + offY][x + offX] = {type: '#' };
        }
        
        //place ascending stairs
        f[0][0] = {type: '<' };
        
        //place walls, max attempts at placing walls to avoid timeout
        for(var i = 0, k = 0; (i < numWalls) && (k < 10000); k++){
            //random position
            var x = 1 + dice(1, w - 3);
            var y = 1 + dice(1, h - 3);
            
            //direction to erect wall in - either v or h, alternate between both
            var dx = i % 2;
            var dy = 1 - dx;
            
            //check for a good starting pos
            if(x + offX == 0) continue;
            if(y + offY == 0) continue;
            if(f[y + offY][x + offX].type != '.') continue;
            if(f[y + offY - 1][x + offX].type != '.') continue;
            if(f[y + offY + 1][x + offX].type != '.') continue;
            if(f[y + offY][x + offX + 1].type != '.') continue;
            if(f[y + offY][x + offX - 1].type != '.') continue;
            
            //two iterations: up then down, or left then right
            for(var j = 0; j < 2; j++){
                var x2, y2;
                for(x2 = x + dx, y2 = y + dy; f[y2 + offY][x2 + offX].type == '.'; x2 += dx, y2 += dy){
                    f[y2 + offY][x2 + offX] = {type: '#' };
                }
                //avoid blocking doors
                if(f[y2 + offY][x2 + offX].type == '+'){
                    x2 -= dx;
                    y2 -= dy;
                    f[y2 + offY][x2 + offX] = {type: '.' };
                }
                
                dx *= -1;
                dy *= -1;
            }
            
            //place door
            f[y + offY][x + offX] = {type: '+' };
            
            i++;
        }
  
        dungeon[n].generated = true;
        
        //place NPCs
        dungeon[n].entities = [];
        for(var i = 0; i < numNPCs;){
            //random position
            var x = 1 + dice(1, w - 3);
            var y = 1 + dice(1, h - 3);
            
            if(f[y + offY][x + offX].type != '.') continue;
            if(f[y + offY][x + offX].entity) continue;
            
            var ent = generateCreature();
            f[y + offY][x + offX].entity = ent;
            ent.y = y + offY;
            ent.x = x + offX;
            ent.floor = n;
            dungeon[n].entities.push(ent);
            
            i++;
        }
        //place items
        for(var i = 0; i < numItems;){
            //random position
            var x = 1 + dice(1, w - 3);
            var y = 1 + dice(1, h - 3);
            
            if(f[y + offY][x + offX].type != '.') continue;
            f[y + offY][x + offX].items = [generateItem()];
            
            i++;
        }
        
        //place downstairs
        for(var i = 0; i < 1;){
            //random position
            var x = 1 + dice(1, w - 3);
            var y = 1 + dice(1, h - 3);
            
            if(f[y + offY][x + offX].type != '.') continue;
            
            f[y + offY][x + offX] = {type: '>'};
            f.downY = y + offY;
            f.downX = x + offX;
            
            i++;
        }
  
        // add a secret room at the bottom (might not be accessible due to corners but that's ok)
        var secretRoomWidth = 4+dice(1,3);
        var secretRoomHeight = 3+dice(1,4);
  
        // top left of secret room:
        var secretRoomX = -2-Math.floor(w/2) + dice(1, Math.floor(w-3));
        var secretRoomY = 3+Math.floor(h/2);
  
        for(var y = secretRoomY; y < secretRoomY+secretRoomHeight; y++){
            f[y] = {};
            for(var x = secretRoomX; x < secretRoomX+secretRoomWidth; x++){
                f[y][x] = {type: '.' };
            }
            f[y][secretRoomX] = {type: '#' };
            f[y][secretRoomX+secretRoomWidth - 1] = {type: '#' };
        }
        for(var x = secretRoomX; x < secretRoomX+secretRoomWidth; x++){
            f[secretRoomY][x] = {type: '#' };
            f[secretRoomY+secretRoomHeight - 1][x] = {type: '#' };
        }
  
        // add door
        f[secretRoomY][secretRoomX+Math.floor(secretRoomWidth/2)] = {type: '+'};
        // add corridor
        var corridorY=secretRoomY-1;
        var found=false;
        var cur=0;
        if (!f[corridorY]) {
           f[corridorY] = {};
        }
        while(!found && cur<h) {
            f[corridorY][secretRoomX+Math.floor(secretRoomWidth/2)] = {type: '.'};
            f[corridorY][secretRoomX+Math.floor(secretRoomWidth/2)-1] = {type: '#'};
            f[corridorY][secretRoomX+Math.floor(secretRoomWidth/2)+1] = {type: '#'};
            corridorY--;
            if (!f[corridorY]) {
               f[corridorY] = {};
            }
            else {
                if (f[corridorY][secretRoomX+Math.floor(secretRoomWidth/2)] && 
                    f[corridorY][secretRoomX+Math.floor(secretRoomWidth/2)].type == '#') {
                    found=true
                }
            }
            cur++;
        }
        //add secret door. this will be displayed as '#'
        f[corridorY][secretRoomX+Math.floor(secretRoomWidth/2)] = {type: '~'};
  
        //todo: add treasure!
  
    }
    
   

    /* ------------------------ DUNGEON / TILES -------------------------- */
  
    function visitTile(x, y) {
        if(!dungeon[player.floor][y] || !dungeon[player.floor][y][x]) {
            return;
        }
        var tile = dungeon[player.floor][y][x];
        if(!tile.visited){
            if(tile.type == ">"){
                textLog("You found a set of stairs leading down");
            }
            if(tile.items && tile.items.length){
                textLog("You found some loot on the floor");
            }
        }
        tile.visited = true;
    }
  
    function getTile(floor, x, y) {
        if (dungeon[floor][y] && dungeon[floor][y][x]) {
            return dungeon[floor][y][x];
        }
        else {
            return {};
        }
    }
    
    function addItemToTileXY(x, y, item) {
        var tile = getTile(player.floor, x, y);
        if(!tile.items) tile.items = [];
        tile.items.push(item);
        return(tile);
    }
  
    function renderMap(xpos, ypos) {
        if(!player || !dungeon[player.floor]) return;
        var visibilityCache = player.visibilityCache = { misses : 0, hits : 0 };
        for (i = 0; i < display.columns; i++) {
            for (j = 0; j < display.rows; j++) {
                curX = i + xpos - Math.floor(display.columns/2);
                curY = j + ypos - Math.floor(display.rows/2);
                renderTile(i, j, curX, curY, visibilityCache);
            }
        }
        //please don't add showTileInfo here, for wait and other commands that tick,
        //and call renderMap may cause repeated displays
    }
    
    function tileBlocksLight(t) {
      return(t.type == '#' || t.type == '+' || t.type == '~');
    }
    
    function tileIsWalkable(t) {
      return(t.type == '#' || t.type == '+' || t.type == '~');
    }

    function computeVisibility(tx, ty, myX, myY, visibilityCache) {
      var key = tx+':'+ty;
      if(typeof visibilityCache[key] == 'undefined') {
        var lightPath = true;
        lineEach(myX, myY, tx, ty, function(x, y) {
          var t = getTile(player.floor, x, y);
          if(typeof visibilityCache[x+':'+y] == 'undefined') {
            visibilityCache[x+':'+y] = lightPath;
          }
          if(tileBlocksLight(t))
            lightPath = false;
        });
      }
      return(visibilityCache[key]);
    }
    
    function renderTile(x, y, tx, ty, visibilityCache) {
        var tile = getTile(player.floor, curX, curY);
        var symbol = tile.type || '';
        var colour = '255,255,255';
        var bgColour = '#111';
        var lightIntensity = 0.1;
        var canSeeTile = false;
        var distanceFromPlayer = distance(tx, ty, player.x, player.y);
        if (distanceFromPlayer <= player.lightRadius) {
            canSeeTile = computeVisibility(tx, ty, player.x, player.y, visibilityCache);
            if(canSeeTile)
              lightIntensity += 1.2 - (distanceFromPlayer / player.lightRadius);
        }
        if (canSeeTile) {
            visitTile(tx, ty);
        }
        else {
            bgColour = "#000";
        }
        if (tile.items) {
            if(symbol == '.') {
                symbol = '*';
                tile.items.forEach(function(it) { // let items override the default symbol
                  if(it.symbol) symbol = it.symbol;
                });
            }
            colour = '255,255,0';
        }
        if (tile.entity) {
            symbol = tile.entity.symbol || '!';
            if(tile.entity.mode == 'attacking')
                colour = '255,100,50';
        }
        // secret door
        if (symbol=='~') {
            symbol='#';
        }
        display.context.fillStyle = bgColour;
        display.context.fillRect(x * display.tileSize, y * display.tileSize, display.tileSize, display.tileSize);
        display.context.fillStyle = tile.visited ? 'rgba('+colour+','+lightIntensity+')' : bgColour;
        display.context.fillText(symbol, x * display.tileSize, y * display.tileSize);
    }
      
    function corpsify(entity) {
        entity.corpseType = entity.type;
        entity.type = 'corpse';
        entity.name += " carcass";
        entity.symbol = 'c';
        delete entity.prefix;
        addItemToTileXY(entity.x, entity.y, entity);
    }
    
    //function for pathfinding - builds a distance field
    function calcDistField(target, maxDist){
        var queue = [];
        var pos2key = ((x, y) => x + ":" + y);
        var field = target.distField = {};
        //consider doors non-solid, so monsters will bump and open then
        
        queue.push({key: pos2key(target.x, target.y), dist: 0});
        while(queue.length > 0){
            var cell = queue.shift();
            if(cell.dist > maxDist) continue;
            if(
                (field.hasOwnProperty(cell.key)) &&
                (field[cell.key] < cell.dist)){
                continue;
            }
            var pos = cell.key.split(":");
            pos = [parseInt(pos[0]), parseInt(pos[1])];
            
            if(tileIsWalkable(getTile(target.floor, pos[0], pos[1]))){
                continue;
            }
            
            field[cell.key] = cell.dist;
            
            queue.push({key: pos2key(pos[0] + 1, pos[1]), dist: cell.dist + 1});
            queue.push({key: pos2key(pos[0] - 1, pos[1]), dist: cell.dist + 1});
            queue.push({key: pos2key(pos[0], pos[1] + 1), dist: cell.dist + 1});
            queue.push({key: pos2key(pos[0], pos[1] - 1), dist: cell.dist + 1});
            
            queue.push({key: pos2key(pos[0] + 1, pos[1] + 1), dist: cell.dist + 1.4142});
            queue.push({key: pos2key(pos[0] + 1, pos[1] - 1), dist: cell.dist + 1.4142});
            queue.push({key: pos2key(pos[0] - 1, pos[1] + 1), dist: cell.dist + 1.4142});
            queue.push({key: pos2key(pos[0] - 1, pos[1] - 1), dist: cell.dist + 1.4142});
        }
    }

    function tick(){
        var new_ents = [];
        
        if(player.confusion){
            player.confusion--;
            if(!player.confusion){
                textLog("Your confusion wanes out!");
            }
        }
 
        each(player.slots, function(item) {
          if(item && item.onTick) item.onTick();
        });
        
        calcDistField(player, 33);
        
        dungeon[player.floor].entities.forEach(function(e) {
            if(e.health < 0) e.isDead = true;
            if(e.isDead) {
                if(e.onDeath) e.onDeath();
                delete getTile(player.floor, e.x, e.y).entity;
                textLog(getName(e) + " dies.");
                corpsify(e);
            } else {
                e.mode = 'idle';
                if (e.onTick) e.onTick();
                new_ents.push(e);
            }
        });
        dungeon[player.floor].entities = new_ents;
    }
    
    function move(ent, x, y) {
        var myX = ent.x;
        var myY = ent.y;
        var isPlayer = ent == player;
        var tile = getTile(ent.floor, myX + x, myY + y);
        if (tile.type == '~') {
            if(isPlayer) textLog("You find a secret door!");
            tile.type = '.';
            return false;
        }
        if (tile.type == '#') {
            return false;
        }
        if (tile.type == '+'){
            if(dice(1,6) > 3){
                tile.type = '-';
                if(isPlayer) textLog("You open the door.");
            }
            else { 
                if(isPlayer) textLog("You bump against the door, but it refuses to budge just yet.");
            }
            return false;
        }
        if(tile.entity && (tile.entity != ent)) {
            AI.attack(ent, tile.entity);
            return false;
        }
        dungeon[ent.floor][ent.y][ent.x].entity = null;
        ent.x += x;
        ent.y += y;
        dungeon[ent.floor][ent.y][ent.x].entity = ent;
        return true;
    }
    
    /* ------------------------ GENERIC ACTIONS -------------------------- */

    var inventoryShortcuts = 'abcdefghijklmnopqrstuvwxyz';

    function inventoryCount(entity) {
      return(entity.inventoryCount);
    }
    
    function inventoryGetFreeShortcut(entity) {
      for(var i = 0; i < inventoryShortcuts.length; i++) {
        var shortcut = inventoryShortcuts.substr(i, 1);
        if(!entity.inventory[shortcut])
          return(shortcut);
      }
    }

    function inventoryAdd(entity, items) {
      if(!items.length) items = [items];
      var shortcuts = [];
      var maxInventory = entity.maxInventory || 15;
      if(!entity.inventory) entity.inventory = {};
      while (items.length > 0 && entity.inventoryCount < maxInventory) {
        var shortcut = inventoryGetFreeShortcut(entity);
        shortcuts.push(shortcut);
        var item = items.pop();
              entity.inventory[shortcut] = item;
        entity.inventoryCount++;
              textLog(getSubjectAndVerb(entity, 'pick') + " up " + 
                getName(item) + (entity == player ? ' ['+shortcut+']' : '') + ".");
      }
      return shortcuts;
    }
    
    function inventoryItemGetSlot(entity, it) {
        var slot = false;
        each(entity.slots, function(slotItem, slotName) {
          if(slotItem && slotItem == it) slot = slotName;
          });
        return slot;
    }

    function inventoryRemove(entity, items) {
          if(!entity.inventory) return;
          while(items.length > 0) {
        var removeItem = items.pop();
        each(entity.inventory, function(invItem, invShortcut) {
          if(invItem == removeItem) {
            delete entity.inventory[invShortcut];
            entity.inventoryCount--;
          }
        });
      }
    }
    
    var AI = {
      
        playerCanSee : function(obj) {
          return(player.visibilityCache && player.visibilityCache[obj.x + ":" + obj.y]);          
        },      

        //uses distance field to pursue a target
        pursueAndAttack : function(entity, target) {
            entity.mode = 'attacking';
          
            var field;

            if(!(field = target.distField)){
                throw "target distField not built";
                return;
            }
            
            var pos2key = ((x, y) => x + ":" + y);
            
            var myDist = field[pos2key(entity.x, entity.y)];
            var dists = [
                field[pos2key(entity.x + 1, entity.y)],
                field[pos2key(entity.x - 1, entity.y)],
                field[pos2key(entity.x, entity.y + 1)],
                field[pos2key(entity.x, entity.y - 1)]];
            
            //field cell undefined - must be too far
            if(typeof myDist == "undefined"){
                return;
            }
            
            var entities = [
                getTile(entity.floor, entity.x + 1, entity.y).entity,
                getTile(entity.floor, entity.x - 1, entity.y).entity,
                getTile(entity.floor, entity.x, entity.y + 1).entity,
                getTile(entity.floor, entity.x, entity.y - 1).entity];
            var minDist = myDist;
            var bestDir = -1;
            
            for(var i = 0; i < 4; i++){
                //move to attack target
                if(entities[i] == target){
                    bestDir = i;
                    break;
                }
                //get blocked by non-target entities
                if(entities[i]) continue;
                //avoids undefined field cells
                if(typeof dists[i] == "undefined") continue;
                //try to follow through a path that closes in
                if(dists[i] < minDist){
                    minDist = dists[i];
                    bestDir = i;
                }
            }
            
            //sit still if can't close in or attack
            if(bestDir < 0) return;
            //make move
            move(entity, [1, -1, 0, 0][bestDir], [0, 0, 1, -1][bestDir]);
        },
        
        attack : function(atker, target) {
            var damage = atker.damage || 1;
            var damageType = 'impact';
            var accuracy = 1.0; // must range from > 0 to X, where 1.0 is "normal" 
            var damageTaken = AI.takeDamage(target, damage, accuracy, damageType, atker);
            var effective = damage > 0 ? Math.round((damageTaken/damage)*100) : 0;
            textLog(getSubjectAndVerb(atker, 'attack') + ' ' + getName(target) + 
              ' for ' + damageTaken + ' damage ('+
              effective + '% effective).');
        },
        
        takeDamage : function(victim, amount, accuracy, damageType, attacker) {
            each(victim.slots, function(item) { // FIXME: the problem with these probabilities is that it's order-dependent
                if(item && item.ac && amount > 0 && Math.random() < item.ac / accuracy) {
                    var absorption = item.absorption || 1.0;
                    var prevAmount = amount;
                    amount *= clamp(1-absorption, 0, 1);
                    textLog(getName(item) + ' blocks ' + (prevAmount - amount) + ' damage.');
                }  
            });
            amount = Math.round(clamp(amount, 0, 99999));
            victim.health -= amount;
            return(amount);
        },

    }
    
    
    /* ------------------------ PLAYER ACTIONS -------------------------- */
    
    
    var playerActions = {
      
        go : function(x, y, shift) {
            if(player.confusion){
                var dir = dice(1, 4) - 1;
                x = [1, -1, 0, 0][dir];
                y = [0, 0, 1, -1][dir];
            }
            if (x && y) {
                if(move(player, x, 0)){
                    if(move(player, 0, y)){
                        showTileInfo(player.x, player.y);
                    }
                }
                tick();
            }
            else if (shift) {
                while (move(player, x, y)){
                    tick();
                    showTileInfo(player.x, player.y);
                }
                renderMap(player.x, player.y);
                return;
            }
            else {
                if(move(player, x, y)) showTileInfo(player.x, player.y);
                tick();
            }
            renderMap(player.x, player.y);
        },
        
        pickUp : function() {
            var tile = getTile(player.floor, player.x, player.y);
            if (!tile.items) {
                textLog("There is nothing to pick up.");
                return;
            }
            inventoryAdd(player, tile.items);
            if (player.inventoryCount >= player.maxInventory)
                textLog("You are too full to pick up anything else.");
            if (tile.items.length == 0)
                delete tile.items;
            tick();
            renderMap(player.x, player.y);
        },
        
        showInventory : function() {
            var inv = "You are carrying:<br/>";
            for(var i = 0; i < inventoryShortcuts.length; i++) {
                var shortcut = inventoryShortcuts.substr(i, 1);
                var item = player.inventory[shortcut];
                if(item)
                    inv += ' ' + shortcut + ' - ' + getName(item, 'a ') + '<br/>'; 
            }
            if(player.inventoryCount == 0) 
                inv += "nothing";
            textLog(inv.trim());
        },
        
        toggleButtons : function() {
            var bDiv = document.getElementById("actionDiv");
            bDiv.style.display = (bDiv.style.display == "block") ? "none" : "block";
        },        
        
        wield : function(){
            itemPrompt("Wield what? (- for none)", function(it) {
                if((!inventoryItemGetSlot(player, it)) && freeSlot("weapon")){
                    player.slots.weapon = it;
                    if(it && it.onWield) it.onWield();
                    if(it) textLog("You are now wielding a " + it.name);
                    else textLog("You are now fighting bare-handed");
                    showPlayerStats();
                }
            }, true);
        },
        
        wear : function(){
            itemPrompt("Wear what?", function(it) {
                if((!inventoryItemGetSlot(player, it)) && freeSlot("weapon")){
                    player.slots.armor = it;
                    if(it.onWear) it.onWear();
                    textLog("You are now wearing a " + it.name);
                    showPlayerStats();
                }
            }, false, "armor");
        },
  
        takeOff : function(){
            if(freeSlot("armor")){
                textLog("You are now unarmored.");
            }
        },
        
        putOn : function(){
            var f1 = false, f2 = false, neck = false;
            itemPrompt("Put on what?", function(it) {
                if((!inventoryItemGetSlot(player, it))
                    && (
                        ((it.jewelSlot == "finger") && ((f1 = freeSlot("finger1")) || (f2 = freeSlot("weapon")))) ||
                        ((it.jewelSlot == "neck") && (neck = freeSlot("neck")))
                    )){
                    if(f1) player.slots.finger1 = it;
                    if(f2) player.slots.finger2 = it;
                    if(neck) player.slots.neck = it;
                    if(it.onPut) it.onPut();
                    textLog("You are now wearing a " + it.name);
                    showPlayerStats();
                }
            }, false, "jewelllery");
        },
        
        remove : function(){
            var slot;
            itemPrompt("Remove what?", function(it) {
                if((slot = inventoryItemGetSlot(player, it)) && ({neck: 1, finger1: 1, finger2: 1}[slot])){
                    if(freeSlot(slot)) textLog("You remove your " + it.name);
                }
                else textLog("Can't remove that!");
            });
        },
        
        eat : function() {
            itemPrompt("Eat what?", function(it) {
                if(!loseItem(it)) return;
                textLog("You eat " + getName(it) + ".");
                if (it.onEat) it.onEat();
                tick();
            });
        },
        
        drop : function() {
            itemPrompt("Drop what?", function(it) {
                if(!loseItem(it)) return;
                addItemToTileXY(player.x, player.y, it);
                textLog("You drop " + getName(it) + ".");
                tick();
                renderMap(player.x, player.y);
            });
        },
        
        closeDoor : function(){
            var dirs = "hjklbnyu";
            prompt("Which direction?", function(ans) {
                ans = ans.toLowerCase();
                if(dirs.indexOf(ans) < 0 || dirs.indexOf(ans) > dirs.length || ans.length > 1){
                    textLog("No such direction.");
                    return; 
                }
                var x = shortcuts[ans].args[0];
                var y = shortcuts[ans].args[1];
                var t = getTile(player.floor, player.x + x, player.y + y);
                if(t.type == '-'){
                    t.type = '+';
                    textLog("You close the door.");
                }
                else if(t.type == '+'){
                    textLog("That door is already closed.");
                }
                else{
                    textLog("I don't see an open door there.");
                }
                tick();
                renderMap(player.x, player.y);
            });
        },
        
        useStairs : function(dir){
            if((getTile(player.floor, player.x, player.y).type != '<' && dir < 0)
               || (getTile(player.floor, player.x, player.y).type != '>' && dir > 0)) {
                textLog(dir < 0 ? "You can't ascend here." : "You can't descend here.");
                return;
            }
            if(player.floor + dir < 0){
                textLog("You haven't defeated the Big Bad with the MacGuffin yet.");
                return;
            }
            tick();
            player.floor += dir;
            if(!dungeon[player.floor]) {
                generateFloor(player.floor);
            }
            
            var til = getTile(player.floor, player.x, player.y);
            var ent = til.entity;
            if(ent){
                var dx = 0;
                var dy = 1;
                var i;
                for(i = 0; i < 4; i++){
                    if(i % 2){
                        dx *= -1;
                        dy *= -1;
                    }
                    if(i == 2){
                        dx = dy;
                        dy = 0;
                    }
                    if(move(ent, dx, dy)) break;
                }
                if(i == 4){
                    til.ent = null;
                    ent.health = -1;
                    textLog("You squish " + getName(ent));
                }
            }
            if(dir > 0){
                player.x = 0;
                player.y = 0;
            }
            else {
                player.x = dungeon[player.floor].downX;
                player.y = dungeon[player.floor].downY;
            }
            player.go(0, 0);
            textLog("You " + ((dir < 0) ? "asc" : "desc") + "ended to floor " + player.floor);
            renderMap(player.x, player.y);
        },
      
    }
        
    function loseItem(it){
        if(!it) return true;
        if(inventoryItemGetSlot(player, it)){
            textLog("Your " + it.name + " is in use.");
            return false;
        }
        inventoryRemove(player, [it]);
        return true;
    }
    
    function freeSlot(nam){
        var it;
        if(it = player.slots[nam]){
            if(it.cursed){
                textLog("Your " + it.name + " is cursed!");
                return false;
            }
            if(it.onRemove) it.onRemove();
            if(it.onTakeOff) it.onTakeOff();
            if(it.onUnwield) it.onUnwield();
            player.slots[nam] = null;
        }
        return true;
    }
    
    
    /* ------------------------ USER INTERFACE -------------------------- */

    var promptMode = false;
    var promptTextElement = document.getElementById('prompt_text');
    function prompt(text, f) {
        var pLine = '&gt; ' + text + ' ';
        promptTextElement.innerHTML = pLine;
        promptMode = function(keyEvent) {
          promptMode = false;
          promptTextElement.innerHTML = '';
          if(keyEvent.keyCode != 27) {
            textLog(pLine+keyEvent.key);
            f(keyEvent.key);
          }
        }
    }
    
    function itemPrompt(text, callback, acceptNone, typeRestrict){
        prompt(text, function(ans){
            var item = player.inventory[ans];
            if(!item) {
                textLog("No such item");
                return;
            }
            if(ans == "-" && acceptNone){
                callback(null);
            } else {
                if(typeRestrict && (typeRestrict != item.type)){
                    textLog("That item is not " + typeRestrict + "!");
                } else {
                    callback(item);
                }
            }           
        });
    }

    var textLogElement = document.getElementById("textLog");
    var textLogScrollElement = document.getElementById("textLogScrollPane");
    function textLog(logLine) {
        textLogElement.innerHTML += '<div>' + capitalize(logLine) + '</div>';
        textLogScrollElement.scrollTop = textLogScrollElement.scrollHeight;
    }
    
    var playerStatsElement = document.getElementById('playerStats');
    function showPlayerStats() {
        var s = [];
        each(player.slots, function(item, slotName) {
            var itemName = item ? item.name : '<span style="opacity:0.5">-</span>';
            s.push('<div class="stat-section linediv"><div class="name">'+capitalize(slotName)+'</div><div class="content">'+itemName+'</div></div>');
        });
        var inv = [];
        each(player.inventory, function(item, shortcut) {
            inv.push('<div class="stat-section linediv"><div class="name">'+shortcut+'</div><div class="content">'+getName(item, ' ')+'</div></div>');
        });
        playerStatsElement.innerHTML = 
          '<div class="stat-section"><div>Equipped</div><div style="margin-left:16px">' + s.join('') + '</div></div>' +
          '<div class="stat-section"><div>Inventory</div><div style="margin-left:16px">' + inv.join('') + '</div></div>';
    }
  
    function showTileInfo(x, y) {
        var tile = getTile(player.floor, x, y);
        var info = '';
        if (tile.items) {
            if (tile.items.length == 1) info = 'There is ' + getName(tile.items[0], 'a ') +
                ' on the ground in front of you.';
            else info = "There is " + tile.items.slice(0, -1).map(it => getName(it, 'a ')).join(", a ") +
                ", and " + getName(tile.items.slice(-1)[0], 'a ') +
                ' on the ground in front of you.';
        }
        if(tile.type == '<' || tile.type == '>'){
            info += 'There are stairs leading ' + (tile.type == '<' ? 'up' : 'down') + ' in front of you.';
        }
        if (info.length) {
            textLog(info);
        }
        showPlayerStats();
    }

    function handleKeyPress(event) {
        if(promptMode) {
            if(event.key == "Shift") return;
            promptMode(event);
            return;
        }
        var binding = keyBindings[event.key];
        if (binding) {
            if(binding.alias) binding = keyBindings[binding.alias];
            var args = binding.args.slice();
            args.push(event.shiftKey);
            binding.func.apply(null, args);
        }
    }
    
    function doButton(key) {
        if (keyBindings[key]) {
            var binding = keyBindings[key];
            var args = binding.args.slice();
            binding.func.apply(null, args);
        } else {
            console.error('no key binding found for', key);
        }
    }
  
    function createButton(key, binding) {
        var bElement = document.createElement("button");
        bElement.setAttribute("onclick", "doButton('" + key + "')");
        bElement.innerText = binding.action + " (" + key + ")";
        document.getElementById("buttonsDiv").appendChild(bElement);
    }

    function initUI() {
        display.canvas = document.getElementById('canvas');
        display.context = display.canvas.getContext('2d');
        document.addEventListener("keyup", handleKeyPress);
        resizeUI();
        window.onresize = resizeUI();
    }
   
    function resizeUI() {
        var oldWidth = display.canvas.width;
        var oldHeight = display.canvas.height;
        display.canvas.width = document.getElementById('map-pane').clientWidth;
        display.canvas.height = window.innerHeight - document.getElementById('actionDiv').clientHeight - 48;
        display.columns = display.canvas.width / display.tileSize;
        display.rows = display.canvas.height / display.tileSize;
        display.context.font = display.tileSize+'px monospace';
        //so characters are drawn in the correct tile
        //apparently it gets resetted every time the font is changed
        display.context.textBaseline = "top";
        textLogScrollElement.style.height = display.canvas.height+'px';
        if(oldWidth != display.canvas.width || oldHeight != display.canvas.height)
            renderMap(player.x, player.y);
    }

    /* ------------------------ INIT -------------------------- */
  
    initUI();  
    player = generateCreature('player');
    cloneOrMerge(playerActions, player);
    inventoryAdd(player, generateItem('flannel'));
    generateFloor(0);
    player.go(0, 0);

    var keyBindings = {
        "y": { func: player.go, args: [-1, -1] },
        "u": { func: player.go, args: [1, -1] },
        "h": { func: player.go, args: [-1, 0], action: "Go west" },
        "j": { func: player.go, args: [0, 1], action: "Go south" },
        "k": { func: player.go, args: [0, -1], action: "Go north" },
        "l": { func: player.go, args: [1, 0], action: "Go east" },
        "b": { func: player.go, args: [-1, 1] },
        "n": { func: player.go, args: [1, 1] },
        ".": { func: player.go, args: [0, 0], action: "Wait" },
        //Numpad movement keys
        "7": { alias: "y" },
        "8": { alias: "k" },
        "9": { alias: "u" },
        "4": { alias: "h" },
        "5": { alias: "." },
        "6": { alias: "l" },
        "1": { alias: "b" },
        "2": { alias: "j" },
        "3": { alias: "n" },
        "ArrowLeft": { alias: "h" },
        "ArrowUp": { alias: "k" },
        "ArrowDown": { alias: "j" },
        "ArrowRight": { alias: "l" },
        ",": { func: player.pickUp, args: [], action: "Pick up" },
        "i": { func: player.showInventory, args: [], action: "Inventory" },
        "d": { func: player.drop, args: [], action: "Drop" },
        "e": { func: player.eat, args: [], action: "Eat" },
        '<': { func: player.useStairs, args: [-1], action: "Ascend"},
        '>': { func: player.useStairs, args: [1], action: "Descend"},
        'c': { func: player.closeDoor, args: [], action: "Close"},
        "w": { func: player.wield, args: [], action: "Wield" },
        "W": { func: player.wear, args: [], action: "Wear" },
        "T": { func: player.takeOff, args: [], action: "Take off" },
        "P": { func: player.putOn, args: [], action: "Put on" },
        "R": { func: player.remove, args: [], action: "Remove" },
        "t": { func: player.toggleButtons, args: [], action: "Hide Buttons" },
    };
    each(keyBindings, function(binding, key) {
        if (binding.action) 
            createButton(key, binding);            
    });
    resizeUI();
      
    </script>


</body></html>